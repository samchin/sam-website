---
title: "Streamlined Haptic Hearing Analysis"
author: "Emmie Fitz-Gibbon"
date: "2025-04-05"
output: html_document
---

source("Data Processing HH.R")



#Absolute Data Analysis


```{r absolute_threshold_analysis, echo = FALSE, warning = FALSE, message = FALSE}
# Initialize threshold_results as empty dataframe with correct structure
threshold_results <- data.frame(
  PID = numeric(),
  device_type = character(),
  Actuator = character(),
  Threshold = numeric(),
  stringsAsFactors = FALSE
)
cat("Initial threshold_results created with", nrow(threshold_results), "rows\n")

# Process each dataset
for (i in seq_along(data_list)) {
  df <- data_list[[i]]
  
  # Extract device_type and PID
  device_type <- if ("device_type" %in% names(df)) unique(df$device_type)[1] else "unknown"
  pid <- if ("PID" %in% names(df)) unique(df$PID)[1] else as.numeric(i)
  
  cat("\nProcessing participant", pid, "with device", device_type, "\n")
  
  # Log columns for debugging
  cat("Columns in dataset:", paste(names(df), collapse=", "), "\n")
  
  # Check for required columns with fallbacks
  required_columns <- c("Actuator", "Amplitude")
  optional_columns <- c("Correct", "IsReversal")
  
  missing_required <- setdiff(required_columns, names(df))
  missing_optional <- setdiff(optional_columns, names(df))
  
  if (length(missing_required) > 0) {
    cat("Missing required columns:", paste(missing_required, collapse=", "), "\n")
    next  # Skip this dataset
  }
  
  if (length(missing_optional) > 0) {
    cat("Missing optional columns:", paste(missing_optional, collapse=", "), "\n")
    # Add defaults for missing optional columns
    if ("Correct" %in% missing_optional) {
      df$Correct <- TRUE  # Assume all correct by default
    }
  }
  
  # Ensure numeric types for critical columns
  df$Amplitude <- as.numeric(as.character(df$Amplitude))
  
  # Filter out data with missing actuator info
  df <- df %>% filter(!is.na(Actuator) & Actuator != "")
  
  # Get unique actuators
  actuators <- unique(df$Actuator)
  cat("Found", length(actuators), "actuators:", paste(actuators, collapse=", "), "\n")
  
  actuator_thresholds <- list()
  actuator_plots <- list()
  
  for (actuator in actuators) {
    # Subset data for this actuator
    actuator_data <- df %>% filter(Actuator == actuator)
    
    # Skip actuators with too few trials
    if (nrow(actuator_data) < 5) {
      cat("Skipping actuator", actuator, "with only", nrow(actuator_data), "trials\n")
      next
    }
    
    # Add trial numbers
    actuator_data$Trial <- seq_len(nrow(actuator_data))
    
    # Reversal detection using multiple methods
    reversal_rows <- NULL
    
    # First try using IsReversal column if it exists
    if ("IsReversal" %in% names(actuator_data)) {
      cat("  Using IsReversal column for reversal detection\n")
      if (is.logical(actuator_data$IsReversal)) {
        reversal_rows <- actuator_data %>% filter(IsReversal == TRUE)
      } else if (is.character(actuator_data$IsReversal)) {
        reversal_rows <- actuator_data %>% filter(toupper(IsReversal) %in% c("TRUE", "T", "YES", "Y"))
      } else {
        # If IsReversal is numeric, treat non-zero as TRUE
        reversal_rows <- actuator_data %>% filter(as.numeric(IsReversal) != 0)
      }
    }
    
    # No fallback method for reversal detection
    # Only use the IsReversal column when it exists
    if (is.null(reversal_rows)) {
      reversal_rows <- data.frame()  # Empty dataframe if no reversals found
      cat("  No IsReversal column or no reversals found\n")
    }
    
    reversal_count <- nrow(reversal_rows)
    cat("  Actuator", actuator, "has", reversal_count, "reversal points\n")
    
    # Find incorrect responses
    incorrect_data <- data.frame()  # Default to empty
    
    if ("Correct" %in% names(actuator_data)) {
      if (is.logical(actuator_data$Correct)) {
        incorrect_data <- actuator_data %>% filter(Correct == FALSE)
      } else if (is.character(actuator_data$Correct)) {
        incorrect_data <- actuator_data %>% filter(toupper(Correct) %in% c("FALSE", "F", "NO", "N"))
      } else {
        # If Correct is numeric, treat zero as FALSE
        incorrect_data <- actuator_data %>% filter(as.numeric(Correct) == 0)
      }
    }
    
    # Compute threshold (average of last 4 reversals or all if fewer)
    avg_value <- NA
    if (reversal_count >= 4) {
      # Make sure we use the last 4 reversals by sorting first
      reversal_rows <- reversal_rows %>% arrange(Trial)
      last_four <- tail(reversal_rows, 4)
      avg_value <- mean(last_four$Amplitude, na.rm = TRUE)
      cat("    Using last 4 reversals. Amplitudes:", paste(last_four$Amplitude, collapse=", "), "\n")
      cat("    Calculated threshold:", avg_value, "\n")
    } else if (reversal_count > 0) {
      avg_value <- mean(reversal_rows$Amplitude, na.rm = TRUE)
      cat("    Using all available reversals. Amplitudes:", paste(reversal_rows$Amplitude, collapse=", "), "\n")
      cat("    Calculated threshold:", avg_value, "\n")
    } else {
      # No alternative method - keep as NA
      avg_value <- NA
      cat("    No reversals found - threshold calculation not possible\n")
    }
    
    actuator_thresholds[[as.character(actuator)]] <- avg_value
    
    # Create plot
    p <- ggplot(actuator_data, aes(x = Trial, y = Amplitude, group = 1)) +  # Ensure group=1 for connecting trials
      geom_line(color = "black") +  # Line connecting trials
      geom_point(size = 3) +  # All points
      labs(
        title = paste("Amplitude vs Trial:", device_type, "- Actuator", actuator, "- PID", pid),
        x = "Trial",
        y = "Amplitude",
        color = NULL,
        caption = paste0("Final Threshold: ", ifelse(!is.na(avg_value), round(avg_value, 4), "N/A"))
      ) + 
      theme_minimal()
    
    # Add reversal points
    if (reversal_count > 0) {
      p <- p + geom_point(data = reversal_rows, aes(color = "Reversal"), size = 4, shape = 17)
    }
    
    # Add incorrect points
    if (nrow(incorrect_data) > 0) {
      p <- p + geom_point(data = incorrect_data, aes(color = "Incorrect"), size = 2.5, shape = 16)
    }
    
    # Add threshold line
    if (!is.na(avg_value)) {
      p <- p + geom_hline(yintercept = avg_value, color = "#5C9CFA", linetype = "dashed", size = 1)
    }
    
    # Add color scale
    p <- p + scale_color_manual(values = c("Incorrect" = "#FA8072", "Reversal" = "#5C9CFA"))
        # Print individual actuator plot
    print(p)
    
    # Store for later combined plotting
    actuator_plots[[as.character(actuator)]] <- actuator_data
    
    # Add to threshold results
    if (!is.na(avg_value)) {
      new_row <- data.frame(
        PID = pid,
        device_type = device_type,
        Actuator = as.character(actuator),
        Threshold = avg_value,
        stringsAsFactors = FALSE
      )
      threshold_results <- rbind(threshold_results, new_row)
      cat("    Added to threshold_results - now has", nrow(threshold_results), "rows\n")
    }
  }
  
  # Create separate colorful overlay graph for each participant-device
  if (length(actuator_plots) > 0) {
    combined_data <- do.call(rbind, actuator_plots)
    overlay_title <- paste("Amplitude vs Trial (All Actuators) - Device:", device_type, "- PID", pid)
    overlay_plot <- ggplot(combined_data, aes(x = Trial, y = Amplitude, color = factor(Actuator))) +
      geom_line() +
      geom_point(size = 1) +
      labs(title = overlay_title, x = "Trial", y = "Amplitude", color = "Actuator") +
      theme_minimal()
    print(overlay_plot)
  }
}

# Check final results
cat("\nFinal threshold_results has", nrow(threshold_results), "rows\n")

# Filter out NA thresholds for plotting
threshold_results_filtered <- threshold_results %>% filter(!is.na(Threshold))

cat("\nFinal threshold results summary (filtered):\n")
print(head(threshold_results_filtered))

# Create separate threshold summary graphs for each device type
for (device in unique(threshold_results_filtered$device_type)) {
  device_data <- threshold_results_filtered %>% filter(device_type == device)
  
  # Skip if there aren't enough data points
  if (nrow(device_data) < 2) {
    cat("Skipping summary plot for device", device, "- not enough data points\n")
    next
  }
  
  p <- ggplot(device_data, aes(x = Actuator, y = Threshold)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  labs(title = paste("Threshold Distribution by Actuator for Device:", device),
       x = "Actuator",
       y = "Threshold") +
   geom_jitter(width = 0.01, height = 0, alpha = 0.7, color = "black", size = 1) +
  theme_minimal()
  print(p)
}

# Summary stats by device type
cat("\nSummary statistics by device type:\n")
device_summary <- threshold_results_filtered %>%
  group_by(device_type) %>%
  summarise(
    Mean_Threshold = mean(Threshold, na.rm = TRUE),
    SD = sd(Threshold, na.rm = TRUE),
    Min = min(Threshold, na.rm = TRUE),
    Max = max(Threshold, na.rm = TRUE),
    N = n()
  )
print(device_summary)

# Create device comparison plot
ggplot(device_summary, aes(x = device_type, y = Mean_Threshold, fill = device_type)) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin = Mean_Threshold - SD, ymax = Mean_Threshold + SD), width = 0.2) +
  labs(title = "Average Threshold by Device Type",
       x = "Device Type",
       y = "Mean Threshold") +
  theme_bw()+
  theme_minimal()

all_device_data <- threshold_results_filtered

# Ensure Actuator is treated as a factor for proper ordering
all_device_data$Actuator <- factor(all_device_data$Actuator)
all_device_data$device_type <- factor(all_device_data$device_type,
                                      levels = c("bracelet", "necklace", "overear"))

# Create a position variable for proper grouping and spacing
all_device_data$position <- as.numeric(all_device_data$Actuator) + 
  (as.numeric(factor(all_device_data$device_type, levels = c("bracelet", "necklace", "overear"))) - 2) * 0.3

# Create the improved horizontal plot
improved_horizontal <- ggplot(all_device_data, aes(x = position, y = Threshold, fill = device_type)) +
  geom_boxplot(width = 0.25) +
  scale_fill_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA"),
                    name = "Device Type") +
  # Add custom x-axis breaks and labels for actuator groups
  scale_x_continuous(
    breaks = 1:6,  # Centers of actuator groups
    labels = c("0", "1", "2", "3", "4", "5"),
    sec.axis = dup_axis(name = NULL, labels = NULL)  # Add top axis line
  ) +
  labs(title = "Threshold Distribution by Actuator and Device Type",
       x = "Actuator",
       y = "Threshold") +
  # Add vertical separators between actuator groups
  geom_vline(xintercept = 1.5:5.5, linetype = "dashed", color = "gray85") +
  theme_minimal() +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),  # Remove vertical grid lines
    panel.border = element_rect(fill = NA, color = "gray90"),
    plot.margin = margin(20, 20, 20, 20)
  )

# Print the improved horizontal plot
print(improved_horizontal)

# Alternative approach - using interaction() for grouping
# This may yield better spacing control
improved_horizontal_alt <- ggplot(all_device_data,
                               aes(x = interaction(Actuator, sep=""),
                                   y = Threshold,
                                   fill = device_type)) +
  geom_boxplot(position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA"),
                    name = "Device Type") +
  labs(title = "Threshold Distribution by Actuator and Device Type",
       x = "Actuator",
       y = "Threshold") +
  theme_minimal() +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    plot.margin = margin(20, 20, 20, 20)
  )

print(improved_horizontal_alt)


generate_all_participant_comparisons <- function(data_list, output_dir = "participant_plots") {
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
    cat("Created output directory:", output_dir, "\n")
  }
  
  # Get all unique participant IDs
  all_pids <- c()
  for (i in seq_along(data_list)) {
    df <- data_list[[i]]
    if ("PID" %in% names(df)) {
      all_pids <- c(all_pids, unique(df$PID))
    }
  }
  all_pids <- unique(all_pids)
  
  cat("Found", length(all_pids), "unique participants\n")
  
  # Create plots for each participant
  #for (pid in all_pids) {
    #cat("Processing participant", pid, "\n")
    #output_file <- file.path(output_dir, paste0("participant_", pid, "_devices.png"))
   # plot <- compare_devices_for_participant(pid, data_list, output_file)
   # if (is.null(plot)) {
    #  cat("  No plot generated for participant", pid, "\n")
    #} else {
   #   cat("  Plot saved for participant", pid, "\n")
   # }
 # }
  
 # cat("All participant plots completed\n")
}

generate_all_participant_comparisons(data_list, output_dir = "device_comparison_plots")
```


## Abs data Summary plots

```{r absolute_threshold_analysis_summarr, echo = FALSE, warning = FALSE, message = FALSE}

# Filter out NA thresholds for plotting
threshold_results_filtered <- threshold_results %>% filter(!is.na(Threshold))
cat("\nFinal threshold results summary (filtered):\n")
print(head(threshold_results_filtered))

# Create separate threshold summary graphs for each device type
for (device in unique(threshold_results_filtered$device_type)) {
  device_data <- threshold_results_filtered %>% filter(device_type == device)
  if (device == "bracelet") {fill = "#FA8072"}
  if (device == "necklace") {fill = "#66BB6A"}
  if (device == "overear") {fill = "#5C9CFA"}
  
  # Skip if there aren't enough data points
  if (nrow(device_data) < 2) {
    cat("Skipping summary plot for device", device, "- not enough data points\n")
    next
  }
  
p <- ggplot(device_data, aes(x = Actuator, y = Threshold)) +
  geom_boxplot(fill = fill, color = "darkblue") +
  labs(title = paste("Threshold Distribution by Actuator for Device:", device), 
       x = "Actuator", 
       y = "Threshold") +
   # geom_jitter(width = 0.01, height = 0, alpha = 0.7, color = "black", size = 1) +
  theme_minimal()
print(p)}

# Summary stats by device type
cat("\nSummary statistics by device type:\n")
device_summary <- threshold_results_filtered %>%
  group_by(device_type) %>%
  summarise(
    Mean_Threshold = mean(Threshold, na.rm = TRUE),
    SD = sd(Threshold, na.rm = TRUE),
    Min = min(Threshold, na.rm = TRUE),
    Max = max(Threshold, na.rm = TRUE),
    N = n()
  )
print(device_summary)

# Create device comparison plot
ggplot(device_summary, aes(x = device_type, y = Mean_Threshold, fill = device_type)) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin = Mean_Threshold - SD, ymax = Mean_Threshold + SD), width = 0.2) +
  labs(title = "Average Threshold by Device Type",
       x = "Device Type",
       y = "Mean Threshold") +
  scale_fill_manual(values = c("#FA8072", "#66BB6A", "#5C9CFA")) +
  theme_minimal()

all_device_data <- threshold_results_filtered


# Create a position variable for proper grouping and spacing
all_device_data$position <- as.numeric(all_device_data$Actuator) + 
  (as.numeric(factor(all_device_data$device_type, levels = c("bracelet", "necklace", "overear"))) - 2) * 0.3

# Create a position variable for proper grouping and spacing
all_device_data$position <- as.numeric(all_device_data$Actuator) + 
  (as.numeric(factor(all_device_data$device_type, levels = c("bracelet", "necklace", "overear"))) - 2) * 0.3

improved_horizontal_alt <- ggplot(all_device_data, 
                               aes(x = Actuator, 
                                   y = Threshold, 
                                   fill = device_type,
                                   group = interaction(Actuator, device_type))) +
  # Use outlier.shape = NA to remove default boxplot outlier points
  geom_boxplot(position = position_dodge(width = 0.8), 
               width = 0.7,
               outlier.shape = NA) +
  scale_fill_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA"),
                    name = "Device Type") +
  labs(title = "Threshold Distribution by Actuator and Device Type",
       x = "Actuator",
       y = "Threshold") +
  theme_minimal() +
  # Make sure color is fixed to blue for ALL points
  geom_point(aes(color = device_type), 
             position = position_jitterdodge(jitter.width = 0., dodge.width = 0.8),
             alpha = 0.5, 
             size = 1) +
  # Add a color scale to match points with their device types
  scale_color_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA"),
                    guide = "none") +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    plot.margin = margin(20, 20, 20, 20)
  )

print(improved_horizontal_alt)


```



```{r device actuator pairs, echo = FALSE, warning = FALSE, message = FALSE}

# Before combining the data, we need to reset trial numbers by actuator for each participant

# Process each dataset to extract and normalize trajectory information
normalized_trajectory_data <- data.frame()

for (i in seq_along(data_list)) {
  df <- data_list[[i]]
  
  # Skip datasets without required columns
  required_columns <- c("Actuator", "Amplitude")
  missing_columns <- setdiff(required_columns, names(df))
  if (length(missing_columns) > 0) {
    next
  }
  
  # Ensure we have device type and PID
  if (!"device_type" %in% names(df) || !"PID" %in% names(df)) {
    next
  }
  
  # Filter out NA or invalid actuators
  df <- df %>% 
    filter(!is.na(Actuator) & Actuator != "" & !is.null(Actuator))
  
  # Reset trial numbers for each participant-actuator combination
  df <- df %>%
    group_by(PID, device_type, Actuator) %>%
    mutate(
      OriginalTrial = if("Trial" %in% names(.)) Trial else row_number(),
      Trial = row_number() # Reset trial numbers starting at 1
    ) %>%
    ungroup()
  
  # Add to combined dataset
  normalized_trajectory_data <- rbind(normalized_trajectory_data, df)
}

# Ensure Amplitude is numeric
normalized_trajectory_data$Amplitude <- as.numeric(normalized_trajectory_data$Amplitude)
normalized_trajectory_data$Actuator <- as.character(normalized_trajectory_data$Actuator)

# Get all unique device-actuator combinations
device_types <- c("bracelet", "necklace", "overear")
actuator_list <- 0:5  # Assuming actuators are numbered 0-5

# Create trajectory plots for each device-actuator combination
for (device in device_types) {
  for (actuator in actuator_list) {
    # Filter data for this device-actuator combination
    combo_data <- normalized_trajectory_data %>%
      filter(device_type == device, Actuator == actuator)
    
    # Skip if no data for this combination
    if (nrow(combo_data) == 0) {
      cat("No data for device:", device, "actuator:", actuator, "\n")
      next
    }
    
    # Calculate number of unique participants
    participants <- unique(combo_data$PID)
    num_participants <- length(participants)
    
    # Create the plot with reset trial numbers
    p <- ggplot(combo_data, aes(x = Trial, y = Amplitude, group = PID, color = PID)) +
      geom_line() +
      geom_point(size = 1) +
      labs(
        title = paste("All Participants:", device, "- Actuator", actuator),
        subtitle = paste(num_participants, "participants"),
        x = "Trial (reset per actuator)",
        y = "Amplitude",
        color = "Participant ID"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 14, hjust = 0.5),
        legend.position = "right"
      )
    
    # Display the plot
    print(p)
    
    # Create a second version with standardized trial numbers
    # This helps compare trajectory shapes when trial counts differ
    if (num_participants > 1) {
      # Normalize trial progression for each participant (0 to 1)
      normalized_data <- combo_data %>%
        group_by(PID) %>%
        mutate(
          MaxTrial = max(Trial),
          NormalizedTrial = Trial / MaxTrial
        ) %>%
        ungroup()
      
      p2 <- ggplot(normalized_data, aes(x = NormalizedTrial, y = Amplitude, group = PID, color = PID)) +
        geom_line() +
        geom_point(size = 1) +
        labs(
          title = paste("Normalized Trajectories:", device, "- Actuator", actuator),
          subtitle = paste(num_participants, "participants"),
          x = "Normalized Trial Position (0-1)",
          y = "Amplitude",
          color = "Participant ID"
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, hjust = 0.5),
          legend.position = "right"
        )
      
      # Display the normalized plot
      print(p2)
    }
  }
}

# For the average trajectories, we also need to use the reset trial numbers
avg_trajectories <- normalized_trajectory_data %>%
  # Normalize trial progression for each participant-device-actuator combination
  group_by(PID, device_type, Actuator) %>%
  mutate(
    MaxTrial = max(Trial),
    TrialPercent = floor((Trial / MaxTrial) * 10) / 10  # Round to nearest 0.1
  ) %>%
  ungroup() %>%
  # Calculate average amplitude at each trial percentage point
  group_by(device_type, Actuator, TrialPercent) %>%
  summarise(
    AvgAmplitude = mean(Amplitude, na.rm = TRUE),
    StdDev = sd(Amplitude, na.rm = TRUE),
    n = n(),
    .groups = 'drop'
  )

# Plot average trajectories for each device type
for (device in device_types) {
  device_data <- avg_trajectories %>% filter(device_type == device)
  
  # Skip if no data
  if (nrow(device_data) == 0) next
  
  p <- ggplot(device_data, aes(x = TrialPercent, y = AvgAmplitude, color = factor(Actuator), group = Actuator)) +
    geom_line(size = 1) +
    geom_point() +
    # Add error ribbons
    geom_ribbon(aes(ymin = AvgAmplitude - StdDev, ymax = AvgAmplitude + StdDev, fill = factor(Actuator)), alpha = 0.2, color = NA) +
    labs(
      title = paste("Average Trajectories by Actuator for", device),
      x = "Normalized Trial Position",
      y = "Average Amplitude",
      color = "Actuator",
      fill = "Actuator"
    ) +
    theme_minimal()
  
  print(p)
}
```


## Localization Accuracy Analysis

```{r localization_analysis, echo = FALSE, warning = FALSE, message = FALSE}

# Double-check that we have Correct column
if (!is.null(localization_combined) && !"Correct" %in% names(localization_combined)) {
  localization_combined$Correct <- ifelse(
    localization_combined$Motor == localization_combined$Response, 1, 0
  )
}

# Accuracy by motor position for each device type
accuracy_by_motor <- localization_combined %>%
  group_by(device_type, Motor) %>%
  summarise(
    Accuracy = mean(Correct, na.rm = TRUE),
    SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
    n = n()
  )


# ===============================================================
# PART 1: LOCALIZATION ACCURACY BY MOTOR POSITION
# ===============================================================

# Calculate device averages for motor position plot
device_averages <- accuracy_by_motor %>%
  group_by(device_type) %>%
  summarise(avg_accuracy = mean(Accuracy, na.rm = TRUE))

# Plot accuracy by motor position for each device
ggplot(accuracy_by_motor, aes(x = Motor, y = Accuracy, color = device_type)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = Accuracy - SE, ymax = Accuracy + SE), width = 0.2) +
  # Add horizontal average lines for each device type
  geom_hline(data = device_averages, 
             aes(yintercept = avg_accuracy, color = device_type),
             linetype = "dashed", size = 1) +
  scale_color_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA")) +
  scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
  labs(
    title = "Localization Accuracy by Motor Position",
    x = "Motor Position",
    y = "Average Accuracy"
  ) +
  facet_wrap(~ device_type) +
  my_theme


# ===============================================================
# PART 2: CONFUSION MATRIX ANALYSIS BY DEVICE TYPE
# ===============================================================

# Check how many rows have NA device types
na_device_count <- sum(is.na(localization_combined$device_type))
cat("Number of rows with NA device_type:", na_device_count, "\n")

# Make sure all three device types are considered
expected_devices <- c("bracelet", "necklace", "overear")
existing_devices <- unique(localization_combined$device_type[!is.na(localization_combined$device_type)])
devices <- unique(c(expected_devices, existing_devices))
cat("Device types to process:", paste(devices, collapse=", "), "\n")

# Process each device type
for (device in devices) {
  # Filter data for current device
  device_data <- localization_combined %>% 
    filter(device_type == device)
  
  cat("\n=====================================\n")
  cat("DEVICE:", device, "\n")
  cat("=====================================\n")
  cat("Number of rows for this device:", nrow(device_data), "\n")
  
  # Only proceed if we have data
  if (nrow(device_data) > 0) {
    # Prepare factor levels for consistent confusion matrix
    all_levels <- sort(unique(c(device_data$Motor, device_data$Response)))
    device_data$Motor_factor <- factor(device_data$Motor, levels = all_levels)
    device_data$Response_factor <- factor(device_data$Response, levels = all_levels)
    
    # Show the confusion matrix
    cat("\nConfusion Matrix for", device, "device:\n")
    
    # Use tryCatch to handle potential errors
    tryCatch({
      # Create and display confusion matrix
      confusion <- confusionMatrix(data = device_data$Response_factor,
                                  reference = device_data$Motor_factor)
      print(confusion)
      
      # Prepare data for visualization
      conf_mat <- as.data.frame(confusion$table)
      conf_mat_wide <- dcast(conf_mat, Prediction ~ Reference, value.var = "Freq")
      conf_mat_matrix <- as.matrix(conf_mat_wide[, -1])
      rownames(conf_mat_matrix) <- conf_mat_wide$Prediction
      
      # Normalize by reference (true) class
      conf_mat_norm <- sweep(conf_mat_matrix, 2, colSums(conf_mat_matrix), "/")
      
      # Convert to long format for ggplot
      conf_mat_long <- melt(conf_mat_norm)
      colnames(conf_mat_long) <- c("Predicted", "Actual", "Proportion")
      
      # Create heatmap visualization
      p <- ggplot(conf_mat_long, aes(x = Actual, y = Predicted, fill = Proportion)) +
        geom_tile() +
        geom_text(aes(label = sprintf("%.2f", Proportion)), size = 3) +
        scale_fill_gradient(low = "white", high = "blue") +
        labs(
          title = paste("Confusion Matrix -", device, "Device"),
          x = "Actual Motor Position",
          y = "Predicted Motor Position",
          fill = "Proportion"
        ) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_x_discrete(limits = rev(levels(conf_mat_long$Actual))) +
        scale_y_discrete(limits = levels(conf_mat_long$Predicted))
      
      print(p)
        
    }, error = function(e) {
      # Error handling - fallback to base R table
      cat("Error creating confusion matrix for", device, "device:", e$message, "\n")
      cat("Falling back to base R table method\n")
      
      # Create a simple confusion matrix using table()
      conf_table <- table(Predicted = device_data$Response, Actual = device_data$Motor)
      print(conf_table)
      
      # Calculate accuracy manually
      accuracy <- sum(diag(conf_table)) / sum(conf_table)
      cat("Accuracy:", round(accuracy * 100, 2), "%\n")
      
      # Visualize using the raw table
      conf_norm <- prop.table(conf_table, margin = 2)  # Normalize by column (actual)
      conf_norm_df <- as.data.frame(conf_norm)
      names(conf_norm_df) <- c("Predicted", "Actual", "Proportion")
      
      # Create heatmap visualization with base R table
      p <- ggplot(conf_norm_df, aes(x = Actual, y = Predicted, fill = Proportion)) +
        geom_tile() +
        geom_text(aes(label = sprintf("%.2f", Proportion)), size = 3) +
        scale_fill_gradient(low = "white", high = "blue") +
        labs(
          title = paste("Confusion Matrix -", device, "Device"),
          x = "Actual Motor Position",
          y = "Predicted Motor Position",
          fill = "Proportion"
        ) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
      
      print(p)
    })
    
    # Display data distribution for this device
    cat("\nMotor distribution for", device, "device:\n")
    print(table(device_data$Motor))
    
    cat("\nResponse distribution for", device, "device:\n")
    print(table(device_data$Response))
    
  } else {
    cat("No data available for device type:", device, "\n")
  }
}


# ===============================================================
# PART 3: LOCALIZATION ACCURACY BY PARTICIPANT
# ===============================================================

# Calculate accuracy by participant
accuracy_by_participant <- localization_combined %>%
  group_by(PID, device_type) %>%
  summarise(
    Accuracy = mean(Correct, na.rm = TRUE),
    n = n()
  ) %>%
  # Filter out any incorrect device types
  filter(device_type %in% c("bracelet", "necklace", "overear")) %>%
  # Clean up device_type to ensure consistent naming
  mutate(device_type = tolower(device_type))

# Calculate average accuracy per device for the participant visualization
participant_device_averages <- accuracy_by_participant %>%
  group_by(device_type) %>%
  summarise(avg_accuracy = mean(Accuracy, na.rm = TRUE))

# Visualize accuracy by participant with average lines
ggplot(accuracy_by_participant, aes(x = factor(PID), y = Accuracy, fill = device_type)) +
  geom_bar(stat = "identity", position = "dodge") +
  # Add horizontal average lines for each device type
  geom_hline(data = participant_device_averages, 
             aes(yintercept = avg_accuracy, color = device_type),
             linetype = "solid", size = 0.6, alpha=0.7) +
  scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
  scale_fill_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA")) +
  scale_color_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA")) +
  labs(
    title = "Localization Accuracy by Participant",
    x = "Participant ID",
    y = "Average Accuracy",
    color = "Device Average"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```


## Two-Point Discrimination Analysis

```{r two_point_analysis, echo = FALSE, warning = FALSE, message = FALSE}
if (!is.null(two_point_combined)) {
  # Ensure data types are correct
  two_point_combined$FirstMotor <- as.numeric(two_point_combined$FirstMotor)
  two_point_combined$SecondMotor <- as.numeric(two_point_combined$SecondMotor)
  two_point_combined$Correct <- as.numeric(two_point_combined$Correct)
  
  # Overall accuracy
  overall_accuracy <- mean(two_point_combined$Correct, na.rm = TRUE)
  cat("Overall two-point discrimination accuracy:", round(overall_accuracy * 100, 2), "%\n")
  
  # Accuracy by device type
  accuracy_by_device <- two_point_combined %>%
    filter(device_type %in% c("bracelet", "necklace", "overear")) %>%
    group_by(device_type) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
      n = n()
    )
  
  cat("\nTwo-point discrimination accuracy by device type:\n")
  print(accuracy_by_device)
  
  # Plot accuracy by device type
  ggplot(accuracy_by_device, aes(x = device_type, y = Accuracy, fill = device_type)) +
    geom_bar(stat = "identity") +
    geom_errorbar(aes(ymin = Accuracy - SE, ymax = Accuracy + SE), width = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    scale_fill_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA")) +
    labs(
      title = "Two-Point Discrimination Accuracy by Device Type",
      x = "Device Type",
      y = "Average Accuracy"
    ) +
    my_theme
  
  
  
  # PID as factor 
  accuracy_by_participant$PID <- as.factor(accuracy_by_participant$PID)
  # Visualize accuracy by participant
  ggplot(accuracy_by_participant, aes(x = PID, y = Accuracy, fill = device_type)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(
      title = "Two-Point Discrimination Accuracy by Participant",
      x = "Participant ID",
      y = "Average Accuracy"
    ) +
    theme_minimal() +
    scale_fill_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA"))+
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
}
  
#convert PID back
  accuracy_by_participant$PID <- as.numeric(accuracy_by_participant$PID)
  
  

    # Accuracy by first motor position
  accuracy_by_first_motor <- two_point_combined %>%
    group_by(device_type, FirstMotor) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
      n = n()
    )
  
  # Plot accuracy by first motor position
  ggplot(accuracy_by_first_motor, aes(x = FirstMotor, y = Accuracy, color = device_type)) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = Accuracy - SE, ymax = Accuracy + SE), width = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(
      title = "Two-Point Discrimination Accuracy by First Motor Position",
      x = "First Motor Position",
      y = "Average Accuracy"
    ) +
    facet_wrap(~ device_type) +
    my_theme
  
  # Accuracy by participant
  accuracy_by_participant <- two_point_combined %>%
    group_by(PID, device_type) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      n = n()
    )
  

    # Calculate distance between motors
  two_point_combined$Distance <- abs(two_point_combined$FirstMotor - two_point_combined$SecondMotor)
  
  # Accuracy by distance between motors
  accuracy_by_distance <- two_point_combined %>%
    group_by(device_type, Distance) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
      n = n()
    )
  
print(accuracy_by_distance)




  
  

```
# two point and localization on the same graph 
```{r two_point_and_localization, echo = FALSE, warning = FALSE, message = FALSE}
# Combined plot of two-point discrimination and localization accuracy
# First, prepare the data frames with a new column to distinguish the data source
# Add data source column to two-point data
accuracy_by_first_motor$data_source <- "Two-Point Discrimination"
# Add data source column to localization data
accuracy_by_motor$data_source <- "Localization"
# Rename columns to match (if needed)
# Assuming FirstMotor in accuracy_by_first_motor corresponds to Motor in accuracy_by_motor
names(accuracy_by_first_motor)[names(accuracy_by_first_motor) == "FirstMotor"] <- "Motor"
# Combine the data frames
combined_data <- bind_rows(accuracy_by_first_motor, accuracy_by_motor)

# Calculate averages by device type and data source for reference lines
avg_by_type <- combined_data %>%
  group_by(device_type, data_source) %>%
  summarise(avg_accuracy = mean(Accuracy, na.rm = TRUE))

# Create the combined plot
ggplot() +
  # Use the same position_dodge object for both points and error bars
  # to ensure they align properly
  {
    # Create a consistent position dodge
    pd <- position_dodge(width = 0.3)
    
    # Use that position dodge for both geom_point and geom_errorbar
    list(
      # Points with different shapes for the two data sources, colors for device types
      geom_point(data = combined_data, 
                aes(x = Motor, y = Accuracy, color = device_type, shape = data_source),
                size = 3, position = pd),
      
      # Error bars
      geom_errorbar(data = combined_data,
                   aes(x = Motor, y = Accuracy, 
                       ymin = Accuracy - SE, ymax = Accuracy + SE,
                       color = device_type, group = interaction(device_type, data_source)), 
                   width = 0.2, 
                   position = pd)
    )
  } +
  # Add average lines - solid for localization
  geom_hline(data = avg_by_type %>% filter(data_source == "Localization"),
             aes(yintercept = avg_accuracy, color = device_type),
             linetype = "solid") +
  # Add average lines - dashed for two-point
  geom_hline(data = avg_by_type %>% filter(data_source == "Two-Point Discrimination"),
             aes(yintercept = avg_accuracy, color = device_type),
             linetype = "dashed") +
  # Use open circles for Two-Point Discrimination
  scale_shape_manual(values = c("Two-Point Discrimination" = 1, "Localization" = 16)) +
  # Customize colors for device types
  scale_color_manual(values = c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA")) +
  # Format y-axis as percentage
  scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
  # Labels
  labs(
    title = "Accuracy by Motor Position",
    subtitle = "Comparing Two-Point Discrimination and Localization Accuracy",
    x = "Motor Position",
    y = "Average Accuracy",
    color = "Device Type",
    shape = "Measure Type"
  ) +
  # Facet by device type
  facet_wrap(~ device_type) +
  # Apply your custom theme
  my_theme +
  # Additional theme customizations
  theme(
    legend.position = "bottom",
    legend.box = "vertical",  # Stack legends vertically
    legend.margin = margin(t = 5, b = 5),
    legend.title = element_text(size = 9),
    legend.text = element_text(size = 8),
    legend.key.size = unit(0.8, "lines"),
    panel.grid.major.y = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5),      # Center title
    plot.subtitle = element_text(hjust = 0.5)    # Center subtitle
  )
```

### Statistical Tests

#Absolute between devices

significant difference between:


Bracelet vs Overear	(t = -4.3525950 , p-adjusted = 2.163993e-04) 
Necklace vs Overear 	(t = -5.9006502	, p-adjusted =	1.141184e-06) 

Bracelet and necklace have lower average abs threshold than overear.

```{r absolute_threshold_stats, echo = FALSE, warning = FALSE, message = FALSE}
# First, inspect the threshold_results_filtered to understand its structure
str(threshold_results_filtered)

# Check for potential list columns that need to be converted
list_cols <- sapply(threshold_results_filtered, is.list)
if(any(list_cols)) {
  cat("Warning: Found list columns that need to be unpacked:", 
      paste(names(threshold_results_filtered)[list_cols], collapse=", "), "\n")
  
  # Try to unpack list columns
  for(col in names(threshold_results_filtered)[list_cols]) {
    cat("Unpacking list column:", col, "\n")
    # If it's a simple list of length 1 elements, try to unlist
    try({
      threshold_results_filtered[[col]] <- unlist(threshold_results_filtered[[col]])
      cat("Successfully unpacked", col, "\n")
    }, silent = TRUE)
  }
}

# Ensure all numeric columns are properly formatted
threshold_results_filtered$Threshold <- as.numeric(as.character(threshold_results_filtered$Threshold))
threshold_results_filtered$Actuator <- as.character(threshold_results_filtered$Actuator)

threshold_results_filtered$bracelet <- unlist(threshold_results_filtered$bracelet)
threshold_results_filtered$necklace <- unlist(threshold_results_filtered$necklace)
threshold_results_filtered$overear <- unlist(threshold_results_filtered$overear)


threshold_results_filtered$Threshold <- unlist(threshold_results_filtered$Threshold)


# Check for NA values introduced during conversion
na_counts <- sapply(threshold_results_filtered, function(x) sum(is.na(x)))
cat("NA counts after conversion:", paste(names(na_counts), na_counts, sep="=", collapse=", "), "\n")

# Reshape data to wide format with better error handling
tryCatch({
  # Print first few rows of the input data

  # Reshape data to wide format for paired tests
  threshold_wide <- tidyr::pivot_wider(
    threshold_results_filtered,
    id_cols = c(PID, Actuator),
    names_from = device_type,
    values_from = Threshold
  )
  
  # Print first few rows of wide data
  cat("\nFirst few rows of threshold_wide:\n")
  print(head(threshold_wide))
  
  # Check for missing values and remove rows with NAs to enable paired tests
  threshold_wide_complete <- na.omit(threshold_wide)
  
  # Print first few rows of complete data
  cat("\nFirst few rows of threshold_wide_complete:\n")
  print(head(threshold_wide_complete))
  
  # Ensure all columns are numeric
  threshold_wide_complete$bracelet <- as.numeric(as.character(threshold_wide_complete$bracelet))
  threshold_wide_complete$necklace <- as.numeric(as.character(threshold_wide_complete$necklace))
  threshold_wide_complete$overear <- as.numeric(as.character(threshold_wide_complete$overear))
  
  # Check data structure before proceeding
  cat("\nStructure of threshold_wide_complete:\n")
  print(str(threshold_wide_complete))
  
  # Now it's safe to proceed with the statistical tests
  if(nrow(threshold_wide_complete) >= 3) {
    cat("\nRunning Shapiro-Wilk tests for normality:\n")
    tryCatch({
      # Calculate differences explicitly
      bn_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$necklace
      bo_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$overear
      no_diff <- threshold_wide_complete$necklace - threshold_wide_complete$overear
      
      # Check for NA or NaN values
      cat("NA/NaN counts in differences: bn=", sum(is.na(bn_diff)), 
          ", bo=", sum(is.na(bo_diff)), 
          ", no=", sum(is.na(no_diff)), "\n")
      
      # Run tests
      if(sum(!is.na(bn_diff)) >= 3) print(shapiro.test(na.omit(bn_diff)))
      if(sum(!is.na(bo_diff)) >= 3) print(shapiro.test(na.omit(bo_diff)))
      if(sum(!is.na(no_diff)) >= 3) print(shapiro.test(na.omit(no_diff)))
    }, error = function(e) {
      cat("Error in Shapiro-Wilk tests:", e$message, "\n")
    })
  } else {
    cat("Not enough complete data for Shapiro-Wilk tests\n")
  }
  
  # Create data frame for repeated measures ANOVA
  cat("\nPreparing data for repeated measures ANOVA\n")
  threshold_long <- tidyr::pivot_longer(
    threshold_wide_complete,
    cols = c("bracelet", "necklace", "overear"),
    names_to = "device_type",
    values_to = "Threshold"
  )
  
  
  
  # Run ANOVA if there's enough data
  if(nrow(threshold_long) >= 5 && length(unique(threshold_long$PID)) >= 2) {
    cat("\nRunning repeated measures ANOVA\n")
    tryCatch({
      aov_model <- aov(Threshold ~ device_type + Error(PID/device_type), data = threshold_long)
      print(summary(aov_model))
    }, error = function(e) {
      cat("Error in ANOVA:", e$message, "\n")
    })
  } else {
    cat("Not enough data for repeated measures ANOVA\n")
  }
  
  # Only run t-tests if we have enough data
  if(nrow(threshold_wide_complete) >= 2) {
    cat("\nRunning paired t-tests\n")
    # Initialize results dataframe
    paired_results <- data.frame(
      Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
      t_value = NA,
      p_value = NA,
      p_adjusted = NA
    )
    
    # Run t-tests with error handling
    tryCatch({
      bn_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$necklace, paired = TRUE)
      bo_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$overear, paired = TRUE)
      no_test <- t.test(threshold_wide_complete$necklace, threshold_wide_complete$overear, paired = TRUE)
      
      # Compile results
      paired_results$t_value <- c(bn_test$statistic, bo_test$statistic, no_test$statistic)
      paired_results$p_value <- c(bn_test$p.value, bo_test$p.value, no_test$p.value)
      paired_results$p_adjusted <- p.adjust(paired_results$p_value, method = "bonferroni")
      
      # Print results
      print(paired_results)
    }, error = function(e) {
      cat("Error in paired t-tests:", e$message, "\n")
    })
  } else {
    cat("Not enough data for paired t-tests\n")
  }
  
  # Run non-parametric alternatives
  if(nrow(threshold_wide_complete) >= 2) {
    cat("\nRunning Wilcoxon signed-rank tests\n")
    # Initialize results dataframe
    wilcox_results <- data.frame(
      Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
      V_statistic = NA,
      p_value = NA,
      p_adjusted = NA
    )
    
    # Run tests with error handling
    tryCatch({
      bn_wilcox <- wilcox.test(threshold_wide_complete$bracelet, threshold_wide_complete$necklace, paired = TRUE)
      bo_wilcox <- wilcox.test(threshold_wide_complete$bracelet, threshold_wide_complete$overear, paired = TRUE)
      no_wilcox <- wilcox.test(threshold_wide_complete$necklace, threshold_wide_complete$overear, paired = TRUE)
      
      # Compile results
      wilcox_results$V_statistic <- c(bn_wilcox$statistic, bo_wilcox$statistic, no_wilcox$statistic)
      wilcox_results$p_value <- c(bn_wilcox$p.value, bo_wilcox$p.value, no_wilcox$p.value)
      wilcox_results$p_adjusted <- p.adjust(wilcox_results$p_value, method = "bonferroni")
      
      # Print results
      print(wilcox_results)
    }, error = function(e) {
      cat("Error in Wilcoxon tests:", e$message, "\n")
    })
  } else {
    cat("Not enough data for Wilcoxon tests\n")
  }
}, error = function(e) {
  cat("Error in data reshaping or analysis:", e$message, "\n")
  
  # Try to provide more detailed diagnostics
  cat("\nDiagnostics for troubleshooting:\n")
  cat("threshold_results_filtered class:", class(threshold_results_filtered), "\n")
  cat("threshold_results_filtered dimensions:", dim(threshold_results_filtered), "\n")
  cat("Column classes:\n")
  print(sapply(threshold_results_filtered, class))
})
```


## Statistical Tests

#Absolute 


```{r absolute_threshold_stats, echo = FALSE, warning = FALSE, message = FALSE}
# First, inspect the threshold_results_filtered to understand its structure
str(threshold_results_filtered)

# Check for potential list columns that need to be converted
list_cols <- sapply(threshold_results_filtered, is.list)
if(any(list_cols)) {
  cat("Warning: Found list columns that need to be unpacked:", 
      paste(names(threshold_results_filtered)[list_cols], collapse=", "), "\n")
  
  # Try to unpack list columns
  for(col in names(threshold_results_filtered)[list_cols]) {
    cat("Unpacking list column:", col, "\n")
    # If it's a simple list of length 1 elements, try to unlist
    try({
      threshold_results_filtered[[col]] <- unlist(threshold_results_filtered[[col]])
      cat("Successfully unpacked", col, "\n")
    }, silent = TRUE)
  }
}

# Ensure all numeric columns are properly formatted
threshold_results_filtered$Threshold <- as.numeric(as.character(threshold_results_filtered$Threshold))
threshold_results_filtered$Actuator <- as.character(threshold_results_filtered$Actuator)
threshold_results_filtered$bracelet <- unlist(threshold_results_filtered$bracelet)
threshold_results_filtered$necklace <- unlist(threshold_results_filtered$necklace)
threshold_results_filtered$overear <- unlist(threshold_results_filtered$overear)
threshold_results_filtered$Threshold <- unlist(threshold_results_filtered$Threshold)

# Check for NA values introduced during conversion
na_counts <- sapply(threshold_results_filtered, function(x) sum(is.na(x)))
cat("NA counts after conversion:", paste(names(na_counts), na_counts, sep="=", collapse=", "), "\n")

# Reshape data to wide format with better error handling
tryCatch(
  {
    # Print first few rows of the input data
    cat("First few rows of threshold_results_filtered:\n")
    print(head(threshold_results_filtered))
    
    # Reshape data to wide format for paired tests
    threshold_wide <- tidyr::pivot_wider(
      threshold_results_filtered,
      id_cols = c(PID, Actuator),
      names_from = device_type,
      values_from = Threshold
    )
    
    # Print first few rows of wide data
    cat("\nFirst few rows of threshold_wide:\n")
    print(head(threshold_wide))
    
    # Check for missing values and remove rows with NAs to enable paired tests
    threshold_wide_complete <- na.omit(threshold_wide)
    
    # Print first few rows of complete data
    cat("\nFirst few rows of threshold_wide_complete:\n")
    print(head(threshold_wide_complete))
    
    # Ensure all columns are numeric
    threshold_wide_complete$bracelet <- as.numeric(as.character(threshold_wide_complete$bracelet))
    threshold_wide_complete$necklace <- as.numeric(as.character(threshold_wide_complete$necklace))
    threshold_wide_complete$overear <- as.numeric(as.character(threshold_wide_complete$overear))
    
    # Check data structure before proceeding
    cat("\nStructure of threshold_wide_complete:\n")
    print(str(threshold_wide_complete))
    
    # Now it's safe to proceed with the statistical tests
    if(nrow(threshold_wide_complete) >= 3) {
      cat("\nRunning Shapiro-Wilk tests for normality:\n")
      tryCatch(
        {
          # Calculate differences explicitly
          bn_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$necklace
          bo_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$overear
          no_diff <- threshold_wide_complete$necklace - threshold_wide_complete$overear
          
          # Check for NA or NaN values
          cat("NA/NaN counts in differences: bn=", sum(is.na(bn_diff)),
              ", bo=", sum(is.na(bo_diff)),
              ", no=", sum(is.na(no_diff)), "\n")
          
          # Run tests
          if(sum(!is.na(bn_diff)) >= 3) print(shapiro.test(na.omit(bn_diff)))
          if(sum(!is.na(bo_diff)) >= 3) print(shapiro.test(na.omit(bo_diff)))
          if(sum(!is.na(no_diff)) >= 3) print(shapiro.test(na.omit(no_diff)))
        }, 
        error = function(e) {
          cat("Error in Shapiro-Wilk tests:", e$message, "\n")
        }
      )
    } else {
      cat("Not enough complete data for Shapiro-Wilk tests\n")
    }
    
    # Create data frame for repeated measures ANOVA
    cat("\nPreparing data for repeated measures ANOVA\n")
    threshold_long <- tidyr::pivot_longer(
      threshold_wide_complete,
      cols = c("bracelet", "necklace", "overear"),
      names_to = "device_type",
      values_to = "Threshold"
    )
    
    # Run ANOVA if there's enough data
    if(nrow(threshold_long) >= 5 && length(unique(threshold_long$PID)) >= 2) {
      cat("\nRunning repeated measures ANOVA\n")
      tryCatch(
        {
          aov_model <- aov(Threshold ~ device_type + Error(PID/device_type), data = threshold_long)
          print(summary(aov_model))
        }, 
        error = function(e) {
          cat("Error in ANOVA:", e$message, "\n")
        }
      )
    } else {
      cat("Not enough data for repeated measures ANOVA\n")
    }
    
    # Only run t-tests if we have enough data
    if(nrow(threshold_wide_complete) >= 2) {
      cat("\nRunning paired t-tests\n")
      # Initialize results dataframe
      paired_results <- data.frame(
        Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
        t_value = NA,
        p_value = NA,
        p_adjusted = NA
      )
      
      tryCatch(
        {
          bn_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$necklace, paired = TRUE)
          bo_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$overear, paired = TRUE)
          no_test <- t.test(threshold_wide_complete$necklace, threshold_wide_complete$overear, paired = TRUE)
          
          # Store results
          paired_results$t_value[1] <- bn_test$statistic
          paired_results$p_value[1] <- bn_test$p.value
          
          paired_results$t_value[2] <- bo_test$statistic
          paired_results$p_value[2] <- bo_test$p.value
          
          paired_results$t_value[3] <- no_test$statistic
          paired_results$p_value[3] <- no_test$p.value
          
          # Apply Bonferroni correction
          paired_results$p_adjusted <- p.adjust(paired_results$p_value, method = "bonferroni")
          
          # Print results
          print(paired_results)
        },
        error = function(e) {
          cat("Error in paired t-tests:", e$message, "\n")
        }
      )
    } else {
      cat("Not enough data for paired t-tests\n")
    }
  },
  error = function(e) {
    cat("Error in data preparation:", e$message, "\n")
  }
)

# First, inspect the threshold_results_filtered to understand its structure
str(threshold_results_filtered)

# Check for potential list columns that need to be converted
list_cols <- sapply(threshold_results_filtered, is.list)
if(any(list_cols)) {
  cat("Warning: Found list columns that need to be unpacked:", 
      paste(names(threshold_results_filtered)[list_cols], collapse=", "), "\n")
  
  # Try to unpack list columns
  for(col in names(threshold_results_filtered)[list_cols]) {
    cat("Unpacking list column:", col, "\n")
    # If it's a simple list of length 1 elements, try to unlist
    try({
      threshold_results_filtered[[col]] <- unlist(threshold_results_filtered[[col]])
      cat("Successfully unpacked", col, "\n")
    }, silent = TRUE)
  }
}

# Ensure all numeric columns are properly formatted
threshold_results_filtered$Threshold <- as.numeric(as.character(threshold_results_filtered$Threshold))
threshold_results_filtered$Actuator <- as.character(threshold_results_filtered$Actuator)
threshold_results_filtered$bracelet <- unlist(threshold_results_filtered$bracelet)
threshold_results_filtered$necklace <- unlist(threshold_results_filtered$necklace)
threshold_results_filtered$overear <- unlist(threshold_results_filtered$overear)
threshold_results_filtered$Threshold <- unlist(threshold_results_filtered$Threshold)

# Check for NA values introduced during conversion
na_counts <- sapply(threshold_results_filtered, function(x) sum(is.na(x)))
cat("NA counts after conversion:", paste(names(na_counts), na_counts, sep="=", collapse=", "), "\n")

# Reshape data to wide format with better error handling
tryCatch(
  {
    # Print first few rows of the input data
    cat("First few rows of threshold_results_filtered:\n")
    print(head(threshold_results_filtered))
    
    # Reshape data to wide format for paired tests
    threshold_wide <- tidyr::pivot_wider(
      threshold_results_filtered,
      id_cols = c(PID, Actuator),
      names_from = device_type,
      values_from = Threshold
    )
    
    # Print first few rows of wide data
    cat("\nFirst few rows of threshold_wide:\n")
    print(head(threshold_wide))
    
    # Check for missing values and remove rows with NAs to enable paired tests
    threshold_wide_complete <- na.omit(threshold_wide)
    
    # Print first few rows of complete data
    cat("\nFirst few rows of threshold_wide_complete:\n")
    print(head(threshold_wide_complete))
    
    # Ensure all columns are numeric
    threshold_wide_complete$bracelet <- as.numeric(as.character(threshold_wide_complete$bracelet))
    threshold_wide_complete$necklace <- as.numeric(as.character(threshold_wide_complete$necklace))
    threshold_wide_complete$overear <- as.numeric(as.character(threshold_wide_complete$overear))
    
    # Check data structure before proceeding
    cat("\nStructure of threshold_wide_complete:\n")
    print(str(threshold_wide_complete))
    
    # Now it's safe to proceed with the statistical tests
    if(nrow(threshold_wide_complete) >= 3) {
      cat("\nRunning Shapiro-Wilk tests for normality:\n")
      tryCatch(
        {
          # Calculate differences explicitly
          bn_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$necklace
          bo_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$overear
          no_diff <- threshold_wide_complete$necklace - threshold_wide_complete$overear
          
          # Check for NA or NaN values
          cat("NA/NaN counts in differences: bn=", sum(is.na(bn_diff)),
              ", bo=", sum(is.na(bo_diff)),
              ", no=", sum(is.na(no_diff)), "\n")
          
          # Run tests
          if(sum(!is.na(bn_diff)) >= 3) print(shapiro.test(na.omit(bn_diff)))
          if(sum(!is.na(bo_diff)) >= 3) print(shapiro.test(na.omit(bo_diff)))
          if(sum(!is.na(no_diff)) >= 3) print(shapiro.test(na.omit(no_diff)))
        }, 
        error = function(e) {
          cat("Error in Shapiro-Wilk tests:", e$message, "\n")
        }
      )
    } else {
      cat("Not enough complete data for Shapiro-Wilk tests\n")
    }
    
    # Create data frame for repeated measures ANOVA
    cat("\nPreparing data for repeated measures ANOVA\n")
    threshold_long <- tidyr::pivot_longer(
      threshold_wide_complete,
      cols = c("bracelet", "necklace", "overear"),
      names_to = "device_type",
      values_to = "Threshold"
    )
    
    # Run ANOVA if there's enough data
    if(nrow(threshold_long) >= 5 && length(unique(threshold_long$PID)) >= 2) {
      cat("\nRunning repeated measures ANOVA\n")
      tryCatch(
        {
          aov_model <- aov(Threshold ~ device_type + Error(PID/device_type), data = threshold_long)
          print(summary(aov_model))
        }, 
        error = function(e) {
          cat("Error in ANOVA:", e$message, "\n")
        }
      )
    } else {
      cat("Not enough data for repeated measures ANOVA\n")
    }
    
    # Only run t-tests if we have enough data
    if(nrow(threshold_wide_complete) >= 2) {
      cat("\nRunning paired t-tests\n")
      # Initialize results dataframe
      paired_results <- data.frame(
        Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
        t_value = NA,
        p_value = NA,
        p_adjusted = NA
      )
      
      tryCatch({
        bn_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$necklace, paired = TRUE)
        bo_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$overear, paired = TRUE)
        no_test <- t.test(threshold_wide_complete$necklace, threshold_wide_complete$overear, paired = TRUE)
        
        # Compile results
        paired_results$t_value <- c(bn_test$statistic, bo_test$statistic, no_test$statistic)
        paired_results$p_value <- c(bn_test$p.value, bo_test$p.value, no_test$p.value)
        paired_results$p_adjusted <- p.adjust(paired_results$p_value, method = "bonferroni")
        
        # Print results
        print(paired_results)
      }, error = function(e) {
        cat("Error in paired t-tests:", e$message, "\n")
      })
    } else {
      cat("Not enough data for paired t-tests\n")
    }
    
    # Run non-parametric alternatives
    if(nrow(threshold_wide_complete) >= 2) {
      cat("\nRunning Wilcoxon signed-rank tests\n")
      # Initialize results dataframe
      wilcox_results <- data.frame(
        Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
        V_statistic = NA,
        p_value = NA,
        p_adjusted = NA
      )
      
      # Run tests with error handling
      tryCatch({
        bn_wilcox <- wilcox.test(threshold_wide_complete$bracelet, threshold_wide_complete$necklace, paired = TRUE)
        bo_wilcox <- wilcox.test(threshold_wide_complete$bracelet, threshold_wide_complete$overear, paired = TRUE)
        no_wilcox <- wilcox.test(threshold_wide_complete$necklace, threshold_wide_complete$overear, paired = TRUE)
        
        # Compile results
        wilcox_results$V_statistic <- c(bn_wilcox$statistic, bo_wilcox$statistic, no_wilcox$statistic)
        wilcox_results$p_value <- c(bn_wilcox$p.value, bo_wilcox$p.value, no_wilcox$p.value)
        wilcox_results$p_adjusted <- p.adjust(wilcox_results$p_value, method = "bonferroni")
        
        # Print results
        print(wilcox_results)
      }, error = function(e) {
        cat("Error in Wilcoxon tests:", e$message, "\n")
      })
    } else {
      cat("Not enough data for Wilcoxon tests\n")
    }
  },
  error = function(e) {
    cat("Error in data reshaping or analysis:", e$message, "\n")
    
    # Try to provide more detailed diagnostics
    cat("\nDiagnostics for troubleshooting:\n")
    cat("threshold_results_filtered class:", class(threshold_results_filtered), "\n")
    cat("threshold_results_filtered dimensions:", dim(threshold_results_filtered), "\n")
    cat("Column classes:\n")
    print(sapply(threshold_results_filtered, class))
  }
)
```


## Absolute between motors: 

After bonferroni correction no significant differences between actuator. Before correction, necklace shows sifnificant difference between actuators.


```{r absolute_threshold_between_motors, echo = FALSE, warning = FALSE, message = FALSE}
# Check for differences between actuators for each device type
threshold_aov_actuator <- aov(Threshold ~ Actuator + Error(PID/Actuator), data = threshold_long)
summary(threshold_aov_actuator)

# You can also analyze by device type separately
for (device in unique(threshold_results_filtered$device_type)) {
  # Subset data for this device
  device_data <- threshold_results_filtered %>% 
    filter(device_type == device)
  
  # Convert to appropriate format
  device_data$PID <- factor(device_data$PID)
  device_data$Actuator <- factor(device_data$Actuator)
  
  # ANOVA for this device
  cat("\n\n=== Actuator differences for", device, "===\n")
  aov_model <- aov(Threshold ~ Actuator + Error(PID/Actuator), data = device_data)
  print(summary(aov_model))
  
  # Post-hoc tests if ANOVA is significant
  # Use pairwise t-tests
  if (length(unique(device_data$Actuator)) > 1) {
    actuator_means <- aggregate(Threshold ~ Actuator, data = device_data, FUN = mean)
    cat("\nMean thresholds by actuator:\n")
    print(actuator_means)
    
    # If there are enough data points, do pairwise comparisons
    if (length(unique(device_data$Actuator)) > 1) {
      cat("\nPairwise comparisons between actuators:\n")
      pairwise_result <- pairwise.t.test(
        device_data$Threshold, 
        device_data$Actuator,
        p.adjust.method = "bonferroni",
        paired = FALSE  # Change to TRUE if fully paired design
      )
      print(pairwise_result)
    }
  }
}
```

##Localization Accuracy Statistical Analysis

```{r localization_accuracy_stats, echo = FALSE, warning = FALSE, message = FALSE}

# Create participant-level summary data
loc_summary <- localization_combined %>%
  group_by(PID, device_type) %>%
  summarise(Accuracy = mean(Correct, na.rm = TRUE)) %>%
  ungroup()

# Convert to wide format
loc_wide <- loc_summary %>%
  pivot_wider(
    id_cols = PID,
    names_from = device_type,
    values_from = Accuracy
  )

# Remove rows with missing values
loc_wide_complete <- na.omit(loc_wide)

# Test for normality
shapiro.test(loc_wide_complete$bracelet - loc_wide_complete$necklace)
shapiro.test(loc_wide_complete$bracelet - loc_wide_complete$overear)
shapiro.test(loc_wide_complete$necklace - loc_wide_complete$overear)

# Reshape for repeated measures
loc_long <- reshape(
  loc_wide_complete,
  idvar = "PID",
  varying = c("bracelet", "necklace", "overear"),
  v.names = "Accuracy",
  timevar = "device_type",
  times = c("bracelet", "necklace", "overear"),
  direction = "long"
)

# Repeated measures ANOVA
loc_aov <- aov(Accuracy ~ device_type + Error(PID/device_type), data = loc_long)
summary(loc_aov)

# Paired t-tests for post-hoc comparisons
loc_bn <- t.test(loc_wide_complete$bracelet, loc_wide_complete$necklace, paired = TRUE)
loc_bo <- t.test(loc_wide_complete$bracelet, loc_wide_complete$overear, paired = TRUE)
loc_no <- t.test(loc_wide_complete$necklace, loc_wide_complete$overear, paired = TRUE)

# Apply Bonferroni correction
loc_p_values <- c(loc_bn$p.value, loc_bo$p.value, loc_no$p.value)
loc_p_adjusted <- p.adjust(loc_p_values, method = "bonferroni")

# Print results
loc_results <- data.frame(
  Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
  t_value = c(loc_bn$statistic, loc_bo$statistic, loc_no$statistic),
  p_value = loc_p_values,
  p_adjusted = loc_p_adjusted
)
print(loc_results)
print(loc_aov)

summary(loc_wide_complete)





```

# Localization Accuracy Statistical Analysis
## Localization between motors  
```{r localization_motor_stats, echo = FALSE, warning = FALSE, message = FALSE}
library(dplyr)
library(ggplot2)
library(lme4)
library(lmerTest)

# Prepare data
localization_for_motor <- localization_combined %>%
  mutate(
    Motor = factor(Motor),
    PID = factor(PID)
  )

    library("emmeans")

# Loop through each device type
for (device in unique(localization_for_motor$device_type)) {
  device_data <- localization_for_motor %>%
    filter(device_type == device)

  cat("\n\n=== Motor position effects for", device, "===\n")

  if (nrow(device_data) > 0) {
    
    
    mixed_lm_model <- lme4 :: glmer(Correct ~ device_type + Motor +  (1 | PID), data = device_data, family = binomial(link = 
                                                                                              "logit"))
    print(summary(mixed_lm_model)

    EMM <- emmeans(mixed_lm_model, ~ device_type + Motor)

contrast(EMM, "pairwise", adjust = "bonferroni")
    # ANOVA and mixed model
    aov_model <- aov(Correct ~ Motor + Error(PID/Motor), data = device_data)
    print(summary(aov_model))

    # Pairwise comparisons
    cat("\nPairwise comparisons between motor positions:\n")
    pairwise_result <- pairwise.t.test(
      device_data$Correct,
      device_data$Motor,
      p.adjust.method = "bonferroni"
    )
    print(pairwise_result)

    # === Participant-level accuracy per Motor ===
    participant_motor_accuracy <- device_data %>%
      group_by(PID, Motor) %>%
      summarize(
        Accuracy = mean(Correct, na.rm = TRUE),
        .groups = "drop"
      )

    # Plot histogram of individual participant accuracies per Motor
    print(
      ggplot(participant_motor_accuracy, aes(x = Accuracy)) +
        geom_histogram(bins = 10, color = "black", fill = "gray") +
        facet_wrap(~ Motor, scales = "free_y") +
        ggtitle(paste("Participant Accuracy by Motor for", device)) +
        xlab("Participant-level Accuracy") +
        ylab("Number of Participants")
    )
  } else {
    cat("Not enough data for analysis")
  }
}


```

##Localization between motors 

```{r localization_motor_stats, echo = FALSE, warning = FALSE, message = FALSE}
# Test for differences between motor positions
# First, prepare the data
localization_for_motor <- localization_combined %>%
  mutate(
    Motor = factor(Motor),
    PID = factor(PID)
  )

# Run separate analysis for each device type
for (device in unique(localization_for_motor$device_type)) {
  device_data <- localization_for_motor %>% 
    filter(device_type == device)
  
  cat("\n\n=== Motor position effects for", device, "===\n")
  
  # Check if we have enough data
  if (nrow(device_data) > 0) {
    # ANOVA to test effect of motor position on accuracy
    aov_model <- aov(Correct ~ Motor + Error(PID/Motor), data = device_data)
    mixed_lm_model <- lmer(Correct ~ Motor + (Motor | PID), data = device_data)

    

    print(summary(aov_model))

    # Calculate and print accuracy by motor position
    motor_accuracy <- device_data %>%
      group_by(Motor) %>%
      summarize(
        Accuracy = mean(Correct, na.rm = TRUE),
        SD = sd(Correct, na.rm = TRUE),
        n = n()
      )
    
    cat("\nAccuracy by motor position:\n")
    print(motor_accuracy)
  
      # Separate histograms by group using facets
  
    
    # Pairwise comparisons if overall test is significant
    cat("\nPairwise comparisons between motor positions:\n")
    pairwise_result <- pairwise.t.test(
      device_data$Correct, 
      device_data$Motor,
      p.adjust.method = "bonferroni"
    )
    print(pairwise_result)
  } else {
    cat("Not enough data for analysis")
  }
}

     print(summary(mixed_lm_model))
     
    ggplot(motor_accuracy, aes(x = motor_accuracy$Accuracy)) +
    geom_histogram(bins = 30) +
    facet_wrap(~ device_type + motor_accuracy$Motor)
     
     


```

## Two point accuracy 
```{r two_point_accuracy_stats, echo = FALSE, warning = FALSE, message = FALSE}
# Create participant-level summary data
tp_summary <- two_point_combined %>%
  group_by(PID, device_type) %>%
  summarise(Accuracy = mean(Correct, na.rm = TRUE)) %>%
  ungroup()

# Convert to wide format
tp_wide <- tp_summary %>%
  pivot_wider(
    id_cols = PID,
    names_from = device_type,
    values_from = Accuracy
  )

# Remove rows with missing values
tp_wide_complete <- na.omit(tp_wide)

# Test for normality
shapiro.test(tp_wide_complete$bracelet - tp_wide_complete$necklace)
shapiro.test(tp_wide_complete$bracelet - tp_wide_complete$overear)
shapiro.test(tp_wide_complete$necklace - tp_wide_complete$overear)

# Reshape for repeated measures
tp_long <- reshape(
  tp_wide_complete,
  idvar = "PID",
  varying = c("bracelet", "necklace", "overear"),
  v.names = "Accuracy",
  timevar = "device_type",
  times = c("bracelet", "necklace", "overear"),
  direction = "long"
)

# Repeated measures ANOVA
tp_aov <- aov(Accuracy ~ device_type + Error(PID/device_type), data = tp_long)
summary(tp_aov)

# Paired t-tests for post-hoc comparisons
tp_bn <- t.test(tp_wide_complete$bracelet, tp_wide_complete$necklace, paired = TRUE)
tp_bo <- t.test(tp_wide_complete$bracelet, tp_wide_complete$overear, paired = TRUE)
tp_no <- t.test(tp_wide_complete$necklace, tp_wide_complete$overear, paired = TRUE)

# Apply Bonferroni correction
tp_p_values <- c(tp_bn$p.value, tp_bo$p.value, tp_no$p.value)
tp_p_adjusted <- p.adjust(tp_p_values, method = "bonferroni")

# Print results
tp_results <- data.frame(
  Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
  t_value = c(tp_bn$statistic, tp_bo$statistic, tp_no$statistic),
  p_value = tp_p_values,
  p_adjusted = tp_p_adjusted
)
print(tp_results)


```


## Two point between motors 

```{r two_point_motor_stats, echo = FALSE, warning = FALSE, message = FALSE}
  # For two-point discrimination, we want to analyze the effect of
# motor distance and possibly start position

# First approach: Effect of distance on accuracy
tp_distance_data <- two_point_combined %>%
  mutate(
    Distance = factor(abs(FirstMotor - SecondMotor)),
    PID = factor(PID)
  )

# Analyze by device type
for (device in unique(tp_distance_data$device_type)) {
  device_data <- tp_distance_data %>% 
    filter(device_type == device)
  
  cat("\n\n=== Effect of motor distance for", device, "===\n")
  
  if (nrow(device_data) > 0 && length(unique(device_data$Distance)) > 1) {
    # ANOVA
    aov_model <- aov(Correct ~ Distance + Error(PID/Distance), data = device_data)
    print(summary(aov_model))
    
    # Accuracy by distance
    distance_accuracy <- device_data %>%
      group_by(Distance) %>%
      summarize(
        Accuracy = mean(Correct, na.rm = TRUE),
        SD = sd(Correct, na.rm = TRUE),
        n = n()
      )
    
    cat("\nAccuracy by motor distance:\n")
    print(distance_accuracy)
    
    # Pairwise comparisons
    if (length(unique(device_data$Distance)) > 1) {
      cat("\nPairwise comparisons between distances:\n")
      pairwise_result <- pairwise.t.test(
        device_data$Correct, 
        device_data$Distance,
        p.adjust.method = "bonferroni"
      )
      print(pairwise_result)
    }
  } else {
    cat("Not enough data or variation in distances for analysis")
  }
  
  # Second approach: Effect of first motor position on accuracy
  cat("\n\n=== Effect of first motor position for", device, "===\n")
  
  device_data <- two_point_combined %>%
    filter(device_type == device) %>%
    mutate(
      FirstMotor = factor(FirstMotor),
      PID = factor(PID)
    )
  
  if (nrow(device_data) > 0 && length(unique(device_data$FirstMotor)) > 1) {
    # ANOVA
    aov_model <- aov(Correct ~ FirstMotor + Error(PID/FirstMotor), data = device_data)
    print(summary(aov_model))
    
    # Accuracy by first motor
    motor_accuracy <- device_data %>%
      group_by(FirstMotor) %>%
      summarize(
        Accuracy = mean(Correct, na.rm = TRUE),
        SD = sd(Correct, na.rm = TRUE),
        n = n()
      )
    
    cat("\nAccuracy by first motor position:\n")
    print(motor_accuracy)
    
    # Pairwise comparisons
    if (length(unique(device_data$FirstMotor)) > 1) {
      cat("\nPairwise comparisons between first motor positions:\n")
      pairwise_result <- pairwise.t.test(
        device_data$Correct, 
        device_data$FirstMotor,
        p.adjust.method = "bonferroni"
      )
      print(pairwise_result)
    }
  } else {
    cat("Not enough data or variation in first motor positions for analysis")
  }
}
```




```{r neck_effect_analysis, warning = FALSE, message = FALSE}

# Display summary statistics for neck measurements
cat("Summary of neck measurements (Q55):\n")
summary(questionnaire_data$Q55)
cat("\nStandard deviation:", sd(questionnaire_data$Q55, na.rm = TRUE), "\n")

# Create histogram of neck measurements
ggplot(questionnaire_data, aes(x = Q55)) +
  geom_histogram(bins = 10, fill = "blue", alpha = 0.7) +
  labs(title = "Distribution of Neck Measurements", x = "Neck Circumference (cm)", y = "Count") +
  theme_minimal()


#-----------------------------------------------------------------
# DEVICE-SPECIFIC ANALYSIS
#-----------------------------------------------------------------

#-----------------------------------------------------------------
# 1. ABSOLUTE THRESHOLD ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== ABSOLUTE THRESHOLD ANALYSIS BY DEVICE ===\n")



threshold_results_filtered$PID = as.character(threshold_results_filtered$PID)
questionnaire_data$PID = as.character(questionnaire_data$PID)

# Merge threshold data with questionnaire data
threshold_with_neck <- threshold_results_filtered %>%
  inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")

# Check the merged dataset 
cat("\nRows in merged threshold data:", nrow(threshold_with_neck), "\n")

# Device-specific models for threshold data
for (device in unique(threshold_with_neck$device_type)) {
  device_data <- threshold_with_neck %>% filter(device_type == device)
  
  cat("\n--- Absolute Threshold: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {  # Only run if we have enough data
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Threshold))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q55, device_data$Threshold)
    cat("\nCorrelation between neck size and threshold:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Threshold ~ Q55, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q55, y = Threshold)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Neck Size vs Threshold -", device),
           x = "Neck Circumference (cm)", 
           y = "Threshold") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 2. LOCALIZATION ACCURACY ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== LOCALIZATION ACCURACY ANALYSIS BY DEVICE ===\n")

# Verify structure of localization summary data
cat("Structure of loc_summary:\n")
str(loc_summary)



# Merge localization data with questionnaire data
# This is where the error occurred previously - we need to know the actual structure
# Print column names to debug
cat("\nColumn names in loc_summary:\n")
print(names(loc_summary))


loc_summary$PID = as.numeric(loc_summary$PID)
questionnaire_data$PID = as.numeric(questionnaire_data$PID)


# Based on column names, choose the appropriate approach:
# Option 1: If data is already in long format
if ("device_type" %in% names(tp_summary)) {
  # Convert PID to numeric for joining 
  # CORRECTED: Use as.numeric instead of numeric()
  tp_with_neck <- tp_summary %>%
    mutate(PID = as.numeric(as.character(PID))) %>%
    inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")
  
  # Data is already in correct format
} else {
  # Option 2: If data is in wide format
  # Find which device columns exist
  possible_device_cols <- c("bracelet", "necklace", "overear",
                            "Bracelet", "Necklace", "Overear")
  device_cols <- intersect(names(tp_summary), possible_device_cols)
  
  if (length(device_cols) > 0) {
    # Convert to long format
    tp_with_neck <- tp_summary %>%
      # CORRECTED: Use as.numeric with as.character
      mutate(PID = as.numeric(as.character(PID))) %>%
      inner_join(questionnaire_data %>% select(PID, Q55), by = "PID") %>%
      pivot_longer(
        cols = all_of(device_cols),
        names_to = "device_type",
        values_to = "Accuracy"
      ) %>%
      filter(!is.na(Accuracy))
    
    # Ensure device_type is lowercase
    tp_with_neck$device_type <- tolower(tp_with_neck$device_type)
  } else {
    cat("Warning: Could not identify device columns in tp_summary\n")
    print(names(tp_summary))
    # Create empty dataframe
    tp_with_neck <- data.frame(
      PID = numeric(),
      device_type = character(),
      Accuracy = numeric(),
      Q55 = numeric()
    )
  }
}

# Ensure both PID columns are of the same type
loc_summary$PID <- as.character(loc_summary$PID)
questionnaire_data$PID <- as.character(questionnaire_data$PID)

# Create loc_long with neck measurements included
loc_long <- loc_summary %>%
  inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")

# Device-specific models for localization data
for (device in unique(loc_long$device_type)) {
  device_data <- loc_long %>% filter(device_type == device)
  
  cat("\n--- Localization Accuracy: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q55, device_data$Accuracy)
    cat("\nCorrelation between neck size and accuracy:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Accuracy ~ Q55, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q55, y = Accuracy)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Neck Size vs Localization Accuracy -", device),
           x = "Neck Circumference (cm)", 
           y = "Accuracy") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 3. TWO-POINT DISCRIMINATION ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== TWO-POINT DISCRIMINATION ANALYSIS BY DEVICE ===\n")

# Verify structure of two-point summary data
cat("Structure of tp_summary:\n")
str(tp_summary)
cat("\nColumn names in tp_summary:\n")
print(names(tp_summary))


tp_summary$PID = as.numeric(tp_summary$PID)
questionnaire_data$PID = as.numeric(questionnaire_data$PID)

# Apply same logic as with localization data
# Option 1: If data is already in long format
if ("device_type" %in% names(tp_summary)) {
  # Convert PID to character for joining
  tp_with_neck <- tp_summary %>%
    mutate(PID = as.numeric(as.character(PID))) %>%
    inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")
  
  # Data is already in correct format
} else {
  # Option 2: If data is in wide format
  # Find which device columns exist
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                           "Bracelet", "Necklace", "Overear")
  device_cols <- intersect(names(tp_summary), possible_device_cols)
  
  if (length(device_cols) > 0) {
    # Convert to long format
    tp_with_neck <- tp_summary %>%
      mutate(PID = as.numeric(as.character(PID))) %>%
      inner_join(questionnaire_data %>% select(PID, Q55), by = "PID") %>%
      pivot_longer(
        cols = all_of(device_cols),
        names_to = "device_type",
        values_to = "Accuracy"
      ) %>%
      filter(!is.na(Accuracy))
    
    # Ensure device_type is lowercase
    tp_with_neck$device_type <- tolower(tp_with_neck$device_type)
  } else {
    cat("Warning: Could not identify device columns in tp_summary\n")
    print(names(tp_summary))
    # Create empty dataframe
    tp_with_neck <- data.frame(
      PID = numeric(),
      device_type = character(),
      Accuracy = numeric(),
      Q55 = numeric()
    )
  }
}

# Device-specific models for two-point data
for (device in unique(tp_with_neck$device_type)) {
  device_data <- tp_with_neck %>% filter(device_type == device)
  
  cat("\n--- Two-Point Discrimination: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q55, device_data$Accuracy)
    cat("\nCorrelation between neck size and accuracy:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Accuracy ~ Q55, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q55, y = Accuracy)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Neck Size vs Two-Point Discrimination Accuracy -", device),
           x = "Neck Circumference (cm)", 
           y = "Accuracy") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 4. COMBINED VISUALIZATION OF DEVICE-SPECIFIC EFFECTS
#-----------------------------------------------------------------
cat("\n\n=== COMBINED VISUALIZATION OF DEVICE-SPECIFIC EFFECTS ===\n")

# Initialize a dataframe to store all device-specific effects
device_effects <- data.frame(
  Device = character(),
  Measure = character(),
  Estimate = numeric(),
  SE = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Collect threshold effects
for (device in unique(threshold_with_neck$device_type)) {
  device_data <- threshold_with_neck %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Threshold ~ Q55, data = device_data)
    device_effects <- rbind(device_effects, data.frame(
      Device = device,
      Measure = "Absolute Threshold",
      Estimate = coef(model)["Q55"],
      SE = summary(model)$coefficients["Q55", "Std. Error"],
      p_value = summary(model)$coefficients["Q55", "Pr(>|t|)"]
    ))
  }
}

# Collect localization effects
for (device in unique(loc_long$device_type)) {
  device_data <- loc_long %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Accuracy ~ Q55, data = device_data)
    device_effects <- rbind(device_effects, data.frame(
      Device = device,
      Measure = "Localization Accuracy",
      Estimate = coef(model)["Q55"],
      SE = summary(model)$coefficients["Q55", "Std. Error"],
      p_value = summary(model)$coefficients["Q55", "Pr(>|t|)"]
    ))
  }
}

# Collect two-point effects
for (device in unique(tp_with_neck$device_type)) {
  device_data <- tp_with_neck %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Accuracy ~ Q55, data = device_data)
    device_effects <- rbind(device_effects, data.frame(
      Device = device,
      Measure = "Two-Point Accuracy",
      Estimate = coef(model)["Q55"],
      SE = summary(model)$coefficients["Q55", "Std. Error"],
      p_value = summary(model)$coefficients["Q55", "Pr(>|t|)"]
    ))
  }
}

# Create meaningful labels for the plot
device_effects$Significance <- ifelse(device_effects$p_value < 0.05, "Significant", "Non-significant")
device_effects$Label <- paste(device_effects$Device, "-", device_effects$Measure)
device_effects$Label <- factor(device_effects$Label, levels = device_effects$Label[order(device_effects$Measure, device_effects$Device)])

# Create forest plot of all device-specific effects
if (nrow(device_effects) > 0) {
  p <- ggplot(device_effects, aes(x = Label, y = Estimate, color = Device, shape = Significance)) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = Estimate - 1.96*SE, ymax = Estimate + 1.96*SE), width = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = "Effect of Neck Size on Different Measures by Device",
         x = "",
         y = "Estimate of Neck Size Effect (with 95% CI)") +
    coord_flip() +
    facet_grid(Measure ~ ., scales = "free_y", space = "free") +
    theme_minimal() +
    theme(
      legend.position = "right",
      strip.text = element_text(face = "bold"),
      panel.spacing = unit(1, "lines")
    )
  print(p)
} else {
  cat("Insufficient data for combined visualization\n")
}

#-----------------------------------------------------------------
# 5. WRIST SIZE ANALYSIS - BRACELET DEVICE ONLY
#-----------------------------------------------------------------
cat("\n\n=== WRIST SIZE ANALYSIS - BRACELET DEVICE ONLY ===\n")

# Analyze the relationship between wrist size (Q58) and performance with the bracelet device

threshold_results_filtered$PID = as.numeric(threshold_results_filtered$PID)

# For threshold data
bracelet_threshold <- threshold_results_filtered %>%
  filter(device_type == "bracelet") %>%
  inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")

if (nrow(bracelet_threshold) > 5) {
  cat("\n--- Bracelet Threshold vs Wrist Size ---\n")
  wrist_threshold_model <- lm(Threshold ~ Q58, data = bracelet_threshold)
  print(summary(wrist_threshold_model))
  
  p <- ggplot(bracelet_threshold, aes(x = Q58, y = Threshold)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Wrist Size vs Threshold - Bracelet Device",
         x = "Wrist Circumference (cm)", 
         y = "Threshold") +
    theme_minimal()
  print(p)
} else {
  cat("Insufficient data for bracelet threshold vs wrist size analysis\n")
}

loc_summary$PID = as.numeric(loc_summary$PID)
questionnaire_data$PID = as.numeric(questionnaire_data$PID)


# For localization data - handle both potential data structures
if ("device_type" %in% names(loc_summary)) {
  # If already in long format
  bracelet_loc <- loc_summary %>%
    filter(device_type == "bracelet") %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
} else {
  # If in wide format, check for bracelet column
  if ("bracelet" %in% names(loc_summary) || "Bracelet" %in% names(loc_summary)) {
    bracelet_col <- ifelse("bracelet" %in% names(loc_summary), "bracelet", "Bracelet")
    bracelet_loc <- loc_summary %>%
      select(PID, !!sym(bracelet_col)) %>%
      rename(Accuracy = !!sym(bracelet_col)) %>%
      inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
      filter(!is.na(Accuracy))
  } else {
    # Fallback
    cat("Could not find bracelet data in localization dataset\n")
    bracelet_loc <- data.frame()
  }
}

if (nrow(bracelet_loc) > 5) {
  cat("\n--- Bracelet Localization Accuracy vs Wrist Size ---\n")
  wrist_loc_model <- lm(Accuracy ~ Q58, data = bracelet_loc)
  print(summary(wrist_loc_model))
  
  p <- ggplot(bracelet_loc, aes(x = Q58, y = Accuracy)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Wrist Size vs Localization Accuracy - Bracelet Device",
         x = "Wrist Circumference (cm)", 
         y = "Accuracy") +
    theme_minimal()
  print(p)
} else {
  cat("Insufficient data for bracelet localization vs wrist size analysis\n")
}

# For two-point data - handle both potential data structures
if ("device_type" %in% names(tp_summary)) {
  # If already in long format
  bracelet_tp <- tp_summary %>%
    filter(device_type == "bracelet") %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
} else {
  # If in wide format
  if ("bracelet" %in% names(tp_summary) || "Bracelet" %in% names(tp_summary)) {
    bracelet_col <- ifelse("bracelet" %in% names(tp_summary), "bracelet", "Bracelet")
    bracelet_tp <- tp_summary %>%
      select(PID, !!sym(bracelet_col)) %>%
      rename(Accuracy = !!sym(bracelet_col)) %>%
      inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
      filter(!is.na(Accuracy))
  } else {
    # Fallback
    cat("Could not find bracelet data in two-point dataset\n")
    bracelet_tp <- data.frame()
  }
}

if (nrow(bracelet_tp) > 5) {
  cat("\n--- Bracelet Two-Point Discrimination vs Wrist Size ---\n")
  wrist_tp_model <- lm(Accuracy ~ Q58, data = bracelet_tp)
  print(summary(wrist_tp_model))
  
  p <- ggplot(bracelet_tp, aes(x = Q58, y = Accuracy)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Wrist Size vs Two-Point Discrimination - Bracelet Device",
         x = "Wrist Circumference (cm)", 
         y = "Accuracy") +
    theme_minimal()
  print(p)
} else {
  cat("Insufficient data for bracelet two-point vs wrist size analysis\n")
}

#-----------------------------------------------------------------
# 6. WRIST SIZE FOREST PLOT
#-----------------------------------------------------------------
cat("\n\n=== WRIST SIZE EFFECT VISUALIZATION ===\n")

# Initialize a dataframe to store all device-specific effects for wrist size
wrist_effects <- data.frame(
  Device = character(),
  Measure = character(),
  Estimate = numeric(),
  SE = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Ensure questionnaire_data has PID as numeric for joining
questionnaire_data$PID <- as.numeric(questionnaire_data$PID)

# 1. Collect threshold effects for wrist size
for (device in c("bracelet", "necklace", "overear")) {
  # Filter threshold data for this device
  device_data <- threshold_results_filtered %>% 
    filter(device_type == device) %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
  
  # Only proceed if we have enough data
  if (nrow(device_data) > 5) {
    # Fit linear model
    model <- lm(Threshold ~ Q58, data = device_data)
    
    # Extract and store results
    wrist_effects <- rbind(wrist_effects, data.frame(
      Device = device,
      Measure = "Absolute Threshold",
      Estimate = coef(model)["Q58"],
      SE = summary(model)$coefficients["Q58", "Std. Error"],
      p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
    ))
  }
}

# 2. Collect localization effects for wrist size
# Handle both potential data structures for localization data
if ("device_type" %in% names(loc_summary)) {
  # If already in long format
  loc_wrist <- loc_summary %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
  
  # Analyze each device
  for (device in c("bracelet", "necklace", "overear")) {
    device_data <- loc_wrist %>% filter(device_type == device)
    
    if (nrow(device_data) > 5) {
      model <- lm(Accuracy ~ Q58, data = device_data)
      
      wrist_effects <- rbind(wrist_effects, data.frame(
        Device = device,
        Measure = "Localization Accuracy",
        Estimate = coef(model)["Q58"],
        SE = summary(model)$coefficients["Q58", "Std. Error"],
        p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
      ))
    }
  }
} else {
  # If in wide format
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                           "Bracelet", "Necklace", "Overear")
  available_devices <- intersect(names(loc_summary), possible_device_cols)
  
  if (length(available_devices) > 0) {
    for (device_col in available_devices) {
      device_name <- tolower(device_col)
      
      # Create temporary dataset with just this device
      device_data <- loc_summary %>%
        select(PID, !!sym(device_col)) %>%
        rename(Accuracy = !!sym(device_col)) %>%
        inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
        filter(!is.na(Accuracy))
      
      if (nrow(device_data) > 5) {
        model <- lm(Accuracy ~ Q58, data = device_data)
        
        wrist_effects <- rbind(wrist_effects, data.frame(
          Device = device_name,
          Measure = "Localization Accuracy",
          Estimate = coef(model)["Q58"],
          SE = summary(model)$coefficients["Q58", "Std. Error"],
          p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
        ))
      }
    }
  }
}

# 3. Collect two-point effects for wrist size
# Similar approach as for localization
if ("device_type" %in% names(tp_summary)) {
  # If already in long format
  tp_wrist <- tp_summary %>%
    mutate(PID = as.numeric(as.character(PID))) %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
  
  for (device in c("bracelet", "necklace", "overear")) {
    device_data <- tp_wrist %>% filter(device_type == device)
    
    if (nrow(device_data) > 5) {
      model <- lm(Accuracy ~ Q58, data = device_data)
      
      wrist_effects <- rbind(wrist_effects, data.frame(
        Device = device,
        Measure = "Two-Point Accuracy",
        Estimate = coef(model)["Q58"],
        SE = summary(model)$coefficients["Q58", "Std. Error"],
        p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
      ))
    }
  }
} else {
  # If in wide format
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                          "Bracelet", "Necklace", "Overear")
  available_devices <- intersect(names(tp_summary), possible_device_cols)
  
  if (length(available_devices) > 0) {
    for (device_col in available_devices) {
      device_name <- tolower(device_col)
      
      # Create temporary dataset with just this device
      device_data <- tp_summary %>%
        mutate(PID = as.numeric(as.character(PID))) %>%
        select(PID, !!sym(device_col)) %>%
        rename(Accuracy = !!sym(device_col)) %>%
        inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
        filter(!is.na(Accuracy))
      
      if (nrow(device_data) > 5) {
        model <- lm(Accuracy ~ Q58, data = device_data)
        
        wrist_effects <- rbind(wrist_effects, data.frame(
          Device = device_name,
          Measure = "Two-Point Accuracy",
          Estimate = coef(model)["Q58"],
          SE = summary(model)$coefficients["Q58", "Std. Error"],
          p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
        ))
      }
    }
  }
}

# Create meaningful labels for the plot
wrist_effects$Significance <- ifelse(wrist_effects$p_value < 0.05, "Significant", "Non-significant")
wrist_effects$Label <- paste(wrist_effects$Device, "-", wrist_effects$Measure)
wrist_effects$Label <- factor(wrist_effects$Label, 
                             levels = wrist_effects$Label[order(wrist_effects$Measure, wrist_effects$Device)])

# Use device-specific colors
device_colors <- c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA")

# Create forest plot of all device-specific effects for wrist size
if (nrow(wrist_effects) > 0) {
  p <- ggplot(wrist_effects, aes(x = Label, y = Estimate, color = Device, shape = Significance)) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = Estimate - 1.96*SE, ymax = Estimate + 1.96*SE), width = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = "Effect of Wrist Size on Different Measures by Device",
         subtitle = "Coefficients from linear models with 95% confidence intervals",
         x = "",
         y = "Estimate of Wrist Size Effect") +
    scale_color_manual(values = device_colors) +
    scale_shape_manual(values = c("Significant" = 16, "Non-significant" = 1)) +
    coord_flip() +
    facet_grid(Measure ~ ., scales = "free_y", space = "free") +
    theme_minimal() +
    theme(
      legend.position = "right",
      strip.text = element_text(face = "bold"),
      panel.spacing = unit(1, "lines"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank()
    )
  
  print(p)
} else {
  cat("Insufficient data for combined visualization\n")
}

# Display the data table with all effects
print(wrist_effects)


```




## Age

```{r age_effect_analysis, warning = FALSE, message = FALSE}
# Load required libraries
library(tidyverse)
library(ggplot2)
library(lme4)
library(car)

# Display summary statistics for age
cat("Summary of age (Age):\n")
summary(questionnaire_data$Age)
cat("\nStandard deviation:", sd(questionnaire_data$Age, na.rm = TRUE), "\n")


# Ensure PIDs are numeric type for joining
questionnaire_data$PID <- as.numeric(questionnaire_data$PID)

#-----------------------------------------------------------------
# DEVICE-SPECIFIC ANALYSIS
#-----------------------------------------------------------------

#-----------------------------------------------------------------
# 1. ABSOLUTE THRESHOLD ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== AGE EFFECT ON ABSOLUTE THRESHOLD BY DEVICE ===\n")

# PID as character
threshold_results_filtered$PID <- as.character(threshold_results_filtered$PID)
questionnaire_data$PID <- as.character(questionnaire_data$PID)

# Merge threshold data with questionnaire data
threshold_with_age <- threshold_results_filtered %>%
  inner_join(questionnaire_data %>% select(PID, Age), by = "PID")

# Check the merged dataset 
cat("\nRows in merged threshold data:", nrow(threshold_with_age), "\n")

# Device-specific models for threshold data
for (device in unique(threshold_with_age$device_type)) {
  
  device_data <- threshold_with_age %>% filter(device_type == device)
  
  cat("\n--- Absolute Threshold: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {  # Only run if we have enough data
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Threshold))
     device_data$Age <- as.numeric(device_data$Age)
    # Correlation test
    cor_test <- cor.test(device_data$Age, device_data$Threshold)
    cat("\nCorrelation between age and threshold:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Threshold ~ Age, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    device_data$Age <- as.numeric(device_data$Age)
    # Plot
    p <- ggplot(device_data, aes(x = Age, y = Threshold)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Age vs Threshold -", device),
           x = "Age (years)", 
           y = "Threshold") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 2. LOCALIZATION ACCURACY ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== AGE EFFECT ON LOCALIZATION ACCURACY BY DEVICE ===\n")

# Verify structure of localization summary data
cat("Structure of loc_summary:\n")
str(loc_summary)

# Ensure PIDs are character type
questionnaire_data$PID <- as.numeric(questionnaire_data$PID)

tp_summary$PID <- as.numeric(tp_summary$PID)

# Merge localization data with questionnaire data
# Check if data is already in long format with device_type column
if ("device_type" %in% names(tp_summary)) {
  # Data is already in long format
  tp_with_age <- tp_summary %>%
    inner_join(questionnaire_data %>% select(PID, Age), by = "PID")
} else {
  # Option 2: If data is in wide format
  possible_device_cols <- c("bracelet", "necklace", "overear",
                           "Bracelet", "Necklace", "Overear")
  device_cols <- intersect(names(tp_summary), possible_device_cols)
  
  if (length(device_cols) > 0) {
    # Convert to long format
    tp_with_age <- tp_summary %>%
      inner_join(questionnaire_data %>% select(PID, Age), by = "PID") %>%
      pivot_longer(
        cols = all_of(device_cols),
        names_to = "device_type",
        values_to = "Accuracy"
      ) %>%
      filter(!is.na(Accuracy))
    
    # Ensure device_type is lowercase
    tp_with_age$device_type <- tolower(tp_with_age$device_type)
  } else {
    cat("Warning: Could not identify device columns in tp_summary\n")
    print(names(tp_summary))
    # Create empty dataframe
    tp_with_age <- data.frame(
      PID = character(),
      device_type = character(),
      Accuracy = numeric(),
      Age = numeric()
    )
  }
}
# Device-specific models for localization data
for (device in unique(loc_long$device_type)) {
  device_data <- loc_long %>% filter(device_type == device)
  
  cat("\n--- Localization Accuracy: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  # Debug: Check if Age column exists
  cat("Columns in device_data:", paste(names(device_data), collapse=", "), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    device_data$Accuracy <- as.numeric(device_data$Accuracy)
    
    # Check if Age column exists
    if ("Age" %in% names(device_data)) {
      # Try to convert Age to numeric
      temp_age <- suppressWarnings(as.numeric(as.character(device_data$Age)))
      
      # Check if conversion worked
      if (all(is.na(temp_age))) {
        cat("Error: Failed to convert Age to numeric - all values became NA\n")
        
        # Debug info
        cat("First few values of Age column:\n")
        print(head(device_data$Age))
      } else if (length(temp_age) == 0) {
        cat("Error: Age column exists but has length 0\n")
      } else {
        # Assign converted values
        device_data$Age <- temp_age
        
        # Proceed with analysis
        # Correlation test
        cor_test <- cor.test(device_data$Age, device_data$Accuracy)
        cat("\nCorrelation between age and accuracy:\n")
        cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
        
        # Linear model
        device_model <- lm(Accuracy ~ Age, data = device_data)
        cat("\nLinear model for this device:\n")
        print(summary(device_model))
        
        # Plot
        p <- ggplot(device_data, aes(x = Age, y = Accuracy)) +
          geom_point() +
          geom_smooth(method = "lm") +
          labs(title = paste("Age vs Localization Accuracy -", device),
               x = "Age (years)", 
               y = "Accuracy") +
          theme_minimal()
        print(p)
      }
    } else {
      cat("Error: Age column does not exist in the dataset\n")
      
      # Alternative: Try to join with questionnaire data here
      cat("Attempting to join with questionnaire data to get Age...\n")
      
      # Check if PID exists for joining
      if ("PID" %in% names(device_data) && "PID" %in% names(questionnaire_data) && "Age" %in% names(questionnaire_data)) {
        # Convert PIDs to same type
        device_data$PID <- as.character(device_data$PID)
        questionnaire_data_temp <- questionnaire_data %>% 
          select(PID, Age) %>%
          mutate(PID = as.character(PID))
        
        # Join
        device_data <- device_data %>%
          left_join(questionnaire_data_temp, by = "PID")
        
        cat("After joining, rows:", nrow(device_data), "\n")
        cat("Age column exists after join:", "Age" %in% names(device_data), "\n")
        
        # Check if we have Age values
        if ("Age" %in% names(device_data) && sum(!is.na(device_data$Age)) > 5) {
          # Convert Age to numeric
          device_data$Age <- as.numeric(as.character(device_data$Age))
          
          # Now try analysis again
          # Correlation test
          cor_test <- cor.test(device_data$Age, device_data$Accuracy, use = "complete.obs")
          cat("\nCorrelation between age and accuracy:\n")
          cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
          
          # Linear model
          device_model <- lm(Accuracy ~ Age, data = device_data)
          cat("\nLinear model for this device:\n")
          print(summary(device_model))
          
          # Plot
          p <- ggplot(device_data, aes(x = Age, y = Accuracy)) +
            geom_point() +
            geom_smooth(method = "lm") +
            labs(title = paste("Age vs Localization Accuracy -", device),
                 x = "Age (years)", 
                 y = "Accuracy") +
            theme_minimal()
          print(p)
        } else {
          cat("Still insufficient Age data after join\n")
        }
      } else {
        cat("Missing required columns for join\n")
      }
    }
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 3. TWO-POINT DISCRIMINATION ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== AGE EFFECT ON TWO-POINT DISCRIMINATION BY DEVICE ===\n")

# Verify structure of two-point summary data
cat("Structure of tp_summary:\n")
str(tp_summary)
cat("\nColumn names in tp_summary:\n")
print(names(tp_summary))

# Apply same logic as with localization data
threshold_results_filtered$PID <- as.character(threshold_results_filtered$PID)

questionnaire_data$PID <- as.character(questionnaire_data$PID)

# Convert both PIDs to the same type before joining
tp_summary$PID <- as.character(tp_summary$PID)
questionnaire_data$PID <- as.character(questionnaire_data$PID)

# Now perform the join with matching types
tp_with_age <- tp_summary %>%
  inner_join(questionnaire_data %>% select(PID, Age), by = "PID")

# Device-specific models for two-point data
for (device in unique(tp_with_age$device_type)) {
  device_data <- tp_with_age %>% filter(device_type == device)
  
  cat("\n--- Two-Point Discrimination: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    device_data$Accuracy <- as.numeric(device_data$Accuracy)

    
    device_data$Age <- as.numeric(as.character(device_data$Age))


    
    # Correlation test
    cor_test <- cor.test(device_data$Age, device_data$Accuracy)
    cat("\nCorrelation between age and accuracy:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Accuracy ~ Age, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Age, y = Accuracy)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Age vs Two-Point Discrimination Accuracy -", device),
           x = "Age (years)", 
           y = "Accuracy") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 4. COMBINED VISUALIZATION OF AGE EFFECTS
#-----------------------------------------------------------------
cat("\n\n=== COMBINED VISUALIZATION OF AGE EFFECTS ===\n")

# Initialize a dataframe to store all device-specific effects
age_effects <- data.frame(
  Device = character(),
  Measure = character(),
  Estimate = numeric(),
  SE = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Collect threshold effects
for (device in unique(threshold_with_age$device_type)) {
  device_data <- threshold_with_age %>% filter(device_type == device)
  
  # Convert Age to numeric
  device_data$Age <- as.numeric(as.character(device_data$Age))
  
  if (nrow(device_data) > 5) {
    model <- lm(Threshold ~ Age, data = device_data)
    
    # Extract coefficient information - use safe indexing
    coef_df <- as.data.frame(summary(model)$coefficients)
    
    # Add to age_effects dataframe
    age_effects <- rbind(age_effects, data.frame(
      Device = device,
      Measure = "Absolute Threshold",
      Estimate = coef_df["Age", "Estimate"],
      SE = coef_df["Age", "Std. Error"],
      p_value = coef_df["Age", "Pr(>|t|)"]
    ))
  }
}
# Collect localization effects
for (device in unique(loc_long$device_type)) {
  # First merge with questionnaire data to get Age
  device_data <- loc_long %>% 
    filter(device_type == device) %>%
    # Convert PID to character for joining
    mutate(PID = as.character(PID)) %>%
    # Join with questionnaire data to get Age
    inner_join(questionnaire_data %>% 
                 select(PID, Age) %>% 
                 mutate(PID = as.character(PID)), 
               by = "PID")
  
  cat("\n--- Localization data for device:", device, "---\n")
  cat("Rows after merging with questionnaire data:", nrow(device_data), "\n")
  cat("Columns in merged data:", paste(names(device_data), collapse=", "), "\n")
  
  if (nrow(device_data) > 5) {
    # Convert Age to numeric
    device_data$Age <- as.numeric(as.character(device_data$Age))
    device_data$Accuracy <- as.numeric(device_data$Accuracy)
    
    # Remove NA values
    device_data <- device_data %>% filter(!is.na(Age), !is.na(Accuracy))
    cat("Rows after removing NA values:", nrow(device_data), "\n")
    
    if (nrow(device_data) > 5) {
      # Fit model
      model <- try(lm(Accuracy ~ Age, data = device_data), silent = TRUE)
      
      if (!inherits(model, "try-error")) {
        # Get coefficient table
        coef_table <- summary(model)$coefficients
        
        # Add to age_effects using position indexing
        age_effects <- rbind(age_effects, data.frame(
          Device = device,
          Measure = "Localization Accuracy",
          Estimate = coef_table[2, 1],  # Age coefficient estimate
          SE = coef_table[2, 2],        # Standard error
          p_value = coef_table[2, 4]    # p-value
        ))
        cat("Successfully added", device, "to age_effects\n")
      } else {
        cat("Error fitting model for device", device, "\n")
      }
    } else {
      cat("Insufficient data after removing NAs\n")
    }
  } else {
    cat("Insufficient data for analysis\n")
  }
}

# Collect two-point effects
for (device in unique(tp_with_age$device_type)) {
  device_data <- tp_with_age %>% 
    filter(device_type == device) %>%
    # Convert Age to numeric
    mutate(Age = as.numeric(as.character(Age))) %>%
    # Remove rows with NA
    filter(!is.na(Age), !is.na(Accuracy))
  
  if (nrow(device_data) > 5) {
    # Fit model
    model <- lm(Accuracy ~ Age, data = device_data)
    
    # Get coefficient table
    coef_table <- summary(model)$coefficients
    
    # Use position indexing instead of name indexing for reliability
    age_effects <- rbind(age_effects, data.frame(
      Device = device,
      Measure = "Two-Point Accuracy",
      Estimate = coef_table[2, 1],  # Age coefficient estimate (2nd row, 1st column)
      SE = coef_table[2, 2],        # Standard error (2nd row, 2nd column)
      p_value = coef_table[2, 4]    # p-value (2nd row, 4th column)
    ))
  }
}
# Create meaningful labels for the plot
age_effects$Significance <- ifelse(age_effects$p_value < 0.05, "Significant", "Non-significant")
age_effects$Label <- paste(age_effects$Device, "-", age_effects$Measure)
age_effects$Label <- factor(age_effects$Label, levels = age_effects$Label[order(age_effects$Measure, age_effects$Device)])

# Create forest plot of all device-specific effects
if (nrow(age_effects) > 0) {
  # Use device-specific colors
  device_colors <- c("bracelet" = "#FA8072", "necklace" = "#66BB6A", "overear" = "#5C9CFA")
  
  p <- ggplot(age_effects, aes(x = Label, y = Estimate, color = Device, shape = Significance)) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = Estimate - 1.96*SE, ymax = Estimate + 1.96*SE), width = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = "Effect of Age on Different Measures by Device",
         x = "",
         y = "Estimate of Age Effect (with 95% CI)") +
    scale_color_manual(values = device_colors) +
    scale_shape_manual(values = c("Significant" = 16, "Non-significant" = 1)) +
    coord_flip() +
    facet_grid(Measure ~ ., scales = "free_y", space = "free") +
    theme_minimal() +
    theme(
      legend.position = "right",
      strip.text = element_text(face = "bold"),
      panel.spacing = unit(1, "lines"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank()
    )
  print(p)
} else {
  cat("Insufficient data for combined visualization\n")
}

# Display the data table with all effects
print(age_effects)

#-----------------------------------------------------------------
# 5. INVESTIGATING AGE AS A CONFOUNDING VARIABLE
#-----------------------------------------------------------------
cat("\n\n=== INVESTIGATING AGE AS A CONFOUNDING VARIABLE ===\n")

questionnaire_data$Age <- as.numeric(as.character(questionnaire_data$Age))
# Check correlations between age and anatomical measurements
age_neck_cor <- cor.test(questionnaire_data$Age, questionnaire_data$Q55, use = "pairwise.complete.obs")
age_wrist_cor <- cor.test(questionnaire_data$Age, questionnaire_data$Q58, use = "pairwise.complete.obs")

cat("\nCorrelation between age and neck size:\n")
cat("r =", round(age_neck_cor$estimate, 3), ", p =", round(age_neck_cor$p.value, 3), "\n")

cat("\nCorrelation between age and wrist size:\n")
cat("r =", round(age_wrist_cor$estimate, 3), ", p =", round(age_wrist_cor$p.value, 3), "\n")

# Scatter plots to visualize these relationships
p1 <- ggplot(questionnaire_data, aes(x = Age, y = Q55)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Relationship Between Age and Neck Size",
       x = "Age (years)",
       y = "Neck Circumference (cm)") +
  theme_minimal()

p2 <- ggplot(questionnaire_data, aes(x = Age, y = Q58)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Relationship Between Age and Wrist Size",
       x = "Age (years)",
       y = "Wrist Circumference (cm)") +
  theme_minimal()

print(p1)
print(p2)

# Run multiple regression models for each device to see if age and anatomical
# measurements have independent effects (using absolute threshold as example)

cat("\n=== Multiple regression: Age + Anatomical Measurements ===\n")

# For each device type, run models with both age and neck/wrist measurements
for (device in unique(threshold_results_filtered$device_type)) {
  # First with neck size
  device_data_neck <- threshold_results_filtered %>% 
    filter(device_type == device) %>%
    inner_join(questionnaire_data %>% select(PID, Age, Q55), by = "PID")
  
  # Then with wrist size if it's a bracelet
  if (device == "bracelet") {
    device_data_wrist <- threshold_results_filtered %>% 
      filter(device_type == device) %>%
      inner_join(questionnaire_data %>% select(PID, Age, Q58), by = "PID")
  }
  
  cat("\n--- Multiple regression for", device, "device ---\n")
  
  # Neck size + age
  if (nrow(device_data_neck) > 5) {
    cat("\nModel with age and neck size:\n")
    model_neck <- lm(Threshold ~ Age + Q55, data = device_data_neck)
    print(summary(model_neck))
    
    # Calculate semi-partial correlations to assess unique contributions
    cat("\nANOVA to assess unique contributions:\n")
    print(Anova(model_neck, type = 2))
  }
  
  # Wrist size + age (only for bracelet)
  if (device == "bracelet" && nrow(device_data_wrist) > 5) {
    cat("\nModel with age and wrist size:\n")
    model_wrist <- lm(Threshold ~ Age + Q58, data = device_data_wrist)
    print(summary(model_wrist))
    
    # Calculate semi-partial correlations
    cat("\nANOVA to assess unique contributions:\n")
    print(Anova(model_wrist, type = 2))
  }
}
```
