---
title: "[HapticHearing] Data Analysis"
author: "Data Analyst"
date: "2025-03-24"
output: pdf_document
---

```{r setup, include=FALSE}
# Load required packages
requiredPackages <- c("readr", "tidyverse", "lme4", "dplyr", "caret", "ggplot2", "purrr", "stringr", "reshape2")

for(p in requiredPackages) {
  if(!require(p, character.only = TRUE)) install.packages(p)
  library(p, character.only = TRUE)
}

# Set global theme for plots
my_theme <- theme_minimal() + 
  theme(
    plot.title = element_text(size = 14, hjust = 0.5),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    legend.position = 'top',
    legend.justification = 'center',
    legend.direction = 'horizontal',
    axis.text = element_text(size = 10, color = "grey30")
  )
```

## Data Loading and Processing

```{r load_data, echo = FALSE, warning = FALSE, include = FALSE}

# Function to find the header row and properly format data
find_header_and_transform <- function(file_path) {
  df <- read.csv(file_path, header = FALSE, fill = TRUE, stringsAsFactors = FALSE)
  
  # Look for the row that contains "Timestamp" in the first column (or another known header)
  header_row <- which(df[,1] == "Timestamp")
  
  if (length(header_row) == 0) {
    cat("No valid header found in", file_path, "\n")
    return(NULL)  # Skip file
  }
  
  # Use this row as column names
  colnames(df) <- as.character(df[header_row,])
  
  # Remove rows above the detected header
  df <- df[(header_row + 1):nrow(df),]
  
  # Reset row numbers
  rownames(df) <- NULL
  
  return(df)
}


# Base directory where all participant data is stored
base_dir <- "../Data/Psychophysical Data/"

# If none of the predefined paths work, ask user to specify the directory
if (!dir.exists(base_dir)) {
  cat("Cannot find the data directory. Please modify the script to set 'base_dir' to the correct path.\n")
}

# Get all participant folders - these are the numeric folders (e.g., "576", "272", "658")
participant_folders <- list.dirs(path = base_dir, full.names = TRUE, recursive = FALSE)

# Filter to only include directories that are named with numbers (participant IDs)
participant_folders <- participant_folders[grepl("^[0-9]+$", basename(participant_folders))]

participant_ids <- basename(participant_folders)
cat("Found", length(participant_folders), "participant folders:", paste(participant_ids, collapse=", "), "\n")

# Function to extract metadata from filename
extract_metadata <- function(filename) {
  # Extract the basename of the file
  basename_file <- basename(filename)
  
  # Pattern for files like: two_point_discrimination_overear_pid947_2025-03-23T04-05-13-148Z.csv
  if (grepl("_overear_|_bracelet_|_necklace_", basename_file)) {
    parts <- unlist(strsplit(basename_file, "_"))
    
    # Find device type
    device_index <- which(parts %in% c("overear", "bracelet", "necklace"))
    if (length(device_index) > 0) {
      device_type <- parts[device_index]
      
      # Find test type
      if (grepl("two_point|twopoint", basename_file, ignore.case=TRUE)) {
        test_type <- "two_point_discrimination"
      } else if (grepl("localization", basename_file, ignore.case=TRUE)) {
        test_type <- "localization_accuracy"
      } else if (grepl("absolute", basename_file, ignore.case=TRUE)) {
        test_type <- "absolute_threshold"
      } else {
        test_type <- paste(parts[1:(device_index-1)], collapse="_")
      }
      
      # Find PID
      pid_part <- grep("pid", parts, value=TRUE)
      if (length(pid_part) > 0) {
        pid <- gsub("pid", "", pid_part)
      } else {
        pid <- NA
      }
      
      return(list(
        test_type = test_type,
        device_type = device_type,
        pid = pid,
        timestamp = NA
      ))
    }
  }
  
  # If the structured approach didn't work, try to extract information directly from the filename
  if (grepl("bracelet", basename_file, ignore.case=TRUE)) {
    device_type <- "bracelet"
  } else if (grepl("necklace", basename_file, ignore.case=TRUE)) {
    device_type <- "necklace"
  } else if (grepl("overear", basename_file, ignore.case=TRUE)) {
    device_type <- "overear"
  } else {
    device_type <- NA
  }
  
  if (grepl("two_point|twopoint", basename_file, ignore.case=TRUE)) {
    test_type <- "two_point_discrimination"
  } else if (grepl("localization", basename_file, ignore.case=TRUE)) {
    test_type <- "localization_accuracy"
  } else if (grepl("absolute", basename_file, ignore.case=TRUE)) {
    test_type <- "absolute_threshold"
  } else {
    test_type <- NA
  }
  
  # Try to extract PID
  pid_match <- regexpr("pid\\d+", basename_file)
  if (pid_match > 0) {
    pid_text <- regmatches(basename_file, pid_match)
    pid <- gsub("pid", "", pid_text)
  } else {
    pid <- NA
  }
  
  return(list(
    test_type = test_type,
    device_type = device_type,
    pid = pid,
    timestamp = NA
  ))
}

# Function to find all CSV files that match a specific pattern
find_csv_files <- function(folder_path, pattern) {
  # Get all CSV files in the directory (non-recursive, as we know the structure)
  all_files <- list.files(folder_path, pattern = "\\.csv$", full.names = TRUE, recursive = FALSE)
  cat("  Found", length(all_files), "CSV files in", folder_path, "\n")
  
  # If no files found and this is a participant folder, try different approaches
  if (length(all_files) == 0 && grepl("[0-9]+$", basename(folder_path))) {
    cat("  No CSV files found directly in participant folder. Checking subdirectories...\n")
    
    # Try recursive search
    all_files <- list.files(folder_path, pattern = "\\.csv$", full.names = TRUE, recursive = TRUE)
    cat("  Found", length(all_files), "CSV files with recursive search\n")
  }
  
  # Print file list for debugging
  if (length(all_files) > 0) {
    cat("  CSV files:", paste(basename(all_files), collapse=", "), "\n")
  }
  
  # Extract only those matching the pattern
  files_matching <- all_files[grepl(pattern, all_files, ignore.case = TRUE)]
  cat("  Files matching pattern '", pattern, "': ", length(files_matching), "\n")
  
  if (length(files_matching) > 0) {
    cat("  Matching files:", paste(basename(files_matching), collapse=", "), "\n")
  }
  
  return(files_matching)
}

# Create empty lists for each data type
localization_data <- list()
two_point_data <- list()
absolute_data <- list()

# Loop through each participant folder and extract data
for (pid_folder in participant_folders) {
  pid <- basename(pid_folder)
  
  cat("Processing participant/folder:", pid, "\n")
  
  # Debug: list all CSV files in the folder
  all_csv_files <- list.files(pid_folder, pattern = "\\.csv$", full.names = TRUE, recursive = TRUE)
  cat("  Found", length(all_csv_files), "CSV files in total\n")
  if (length(all_csv_files) > 0) {
    cat("  First few files:", paste(basename(head(all_csv_files)), collapse = ", "), "\n")
  }
  
  # Find and process localization data
  loc_files <- find_csv_files(pid_folder, "localization")
  cat("  Found", length(loc_files), "localization files\n")
  
  for (file in loc_files) {
    cat("  Processing localization file:", basename(file), "\n")
    metadata <- extract_metadata(file)
    device_type <- metadata$device_type
    
    # If metadata extraction failed, try to guess from filename
    if (is.na(device_type)) {
      filename <- basename(file)
      if (grepl("bracelet", filename, ignore.case = TRUE)) {
        device_type <- "bracelet"
      } else if (grepl("necklace", filename, ignore.case = TRUE)) {
        device_type <- "necklace"
      } else if (grepl("overear", filename, ignore.case = TRUE)) {
        device_type <- "overear"
      } else {
        device_type <- "unknown"
      }
      cat("    Guessed device type from filename:", device_type, "\n")
    }
    
    tryCatch({
      # Try reading with different options
      data <- read_csv(file, show_col_types = FALSE)
      
      # Add PID and device type columns if they don't exist
      if (!"PID" %in% names(data)) data$PID <- pid
      data$device_type <- device_type
      #if (!"device_type" %in% names(data)) data$device_type <- device_type
      
      # Check for correct columns
      expected_cols <- c("Trial", "Motor", "Response")
      missing_cols <- expected_cols[!expected_cols %in% names(data)]
      
      if (length(missing_cols) > 0) {
        cat("    Warning: Missing expected columns:", paste(missing_cols, collapse=", "), "\n")
        cat("    Available columns:", paste(names(data), collapse=", "), "\n")
      } else {
        # Add to the appropriate list
        localization_data[[length(localization_data) + 1]] <- data
        cat("    Successfully loaded localization data for device:", device_type, "\n")
      }
    }, error = function(e) {
      cat("    Error loading file:", file, "Error:", e$message, "\n")
      
      # Try alternative reading method if first attempt fails
      tryCatch({
        cat("    Attempting alternative reading method...\n")
        data <- read.csv(file, stringsAsFactors = FALSE)
        data <- as_tibble(data)
        
        # Add PID and device type columns if they don't exist
        if (!"PID" %in% names(data)) data$PID <- pid
        if (!"device_type" %in% names(data)) data$device_type <- device_type
        
        # Check for correct columns
        expected_cols <- c("Trial", "Motor", "Response")
        missing_cols <- expected_cols[!expected_cols %in% names(data)]
        
        if (length(missing_cols) > 0) {
          cat("    Warning: Missing expected columns:", paste(missing_cols, collapse=", "), "\n")
          cat("    Available columns:", paste(names(data), collapse=", "), "\n")
        } else {
          # Add to the appropriate list
          localization_data[[length(localization_data) + 1]] <- data
          cat("    Successfully loaded with alternative method\n")
        }
      }, error = function(e2) {
        cat("    Alternative method also failed:", e2$message, "\n")
      })
    })
  }
  
  # Find and process two-point discrimination data
  tp_files <- find_csv_files(pid_folder, "two[ _\\-]point|twopoint")
  cat("  Found", length(tp_files), "two-point discrimination files\n")
  
  
  for (file in tp_files) {
    cat("  Processing two-point file:", basename(file), "\n")
    metadata <- extract_metadata(file)
    device_type <- metadata$device_type
    
    # If metadata extraction failed, try to guess from filename
    if (is.na(device_type)) {
      filename <- basename(file)
      if (grepl("bracelet", filename, ignore.case = TRUE)) {
        device_type <- "bracelet"
      } else if (grepl("necklace", filename, ignore.case = TRUE)) {
        device_type <- "necklace"
      } else if (grepl("overear", filename, ignore.case = TRUE)) {
        device_type <- "overear"
      } else {
        device_type <- "unknown"
      }
      cat("    Guessed device type from filename:", device_type, "\n")
    }
    
    tryCatch({
      # Try reading with different options
      data <- read_csv(file, show_col_types = FALSE)
      
      # Add PID and device type columns
      data$PID <- pid
      data$device_type <- device_type
      
      # Print data structure for debugging
      cat("    Data columns:", paste(names(data), collapse = ", "), "\n")
      cat("    Number of rows:", nrow(data), "\n")
      
      # Add to the appropriate list
      two_point_data[[length(two_point_data) + 1]] <- data
      
      cat("    Successfully loaded two-point discrimination data for device:", device_type, "\n")
    }, error = function(e) {
      cat("    Error loading file:", file, "Error:", e$message, "\n")
      
      # Try alternative reading method if first attempt fails
      tryCatch({
        cat("    Attempting alternative reading method...\n")
        data <- read.csv(file, stringsAsFactors = FALSE)
        data <- as_tibble(data)
        data$PID <- pid
        data$device_type <- device_type
        
        # Add to the appropriate list
        two_point_data[[length(two_point_data) + 1]] <- data
        
        cat("    Successfully loaded with alternative method\n")
      }, error = function(e2) {
        cat("    Alternative method also failed:", e2$message, "\n")
      })
    })
  }
  
  # Find and process absolute threshold data
  abs_files <- find_csv_files(pid_folder, "absolute")
  cat("  Found", length(abs_files), "absolute threshold files\n")
  
    # Identify absolute threshold files
  abs_files <- find_csv_files(pid_folder, "absolute")
  cat("  Found", length(abs_files), "absolute threshold files\n")
  
  # Apply transformation to load and clean data
  absolute_data <- lapply(abs_files, find_header_and_transform)
  
  
  # If any transformations were successful, combine data
  if (length(absolute_data) > 0) {
    absolute_combined <- bind_rows(absolute_data)
  } else {
    absolute_combined <- NULL
    cat("No absolute threshold datasets were successfully transformed\n")
  }
  
    
  for (file in abs_files) {
    cat("  Processing absolute threshold file:", basename(file), "\n")
    metadata <- extract_metadata(file)
    device_type <- metadata$device_type
    
    # If metadata extraction failed, try to guess from filename
    if (is.na(device_type)) {
      filename <- basename(file)
      if (grepl("bracelet", filename, ignore.case = TRUE)) {
        device_type <- "bracelet"
      } else if (grepl("necklace", filename, ignore.case = TRUE)) {
        device_type <- "necklace"
      } else if (grepl("overear", filename, ignore.case = TRUE)) {
        device_type <- "overear"
      } else {
        device_type <- "unknown"
      }
      cat("    Guessed device type from filename:", device_type, "\n")
    }
    
    tryCatch({
      # Try reading with different options
      data <- read_csv(file, show_col_types = FALSE)
      
      # Add PID and device type columns
      data$PID <- pid
      data$device_type <- device_type
      
      # Print data structure for debugging
      cat("    Data columns:", paste(names(data), collapse = ", "), "\n")
      cat("    Number of rows:", nrow(data), "\n")
      
      # Add to the appropriate list
      absolute_data[[length(absolute_data) + 1]] <- data
      
      cat("    Successfully loaded absolute threshold data for device:", device_type, "\n")
    }, error = function(e) {
      cat("    Error loading file:", file, "Error:", e$message, "\n")
      
      # Try alternative reading method if first attempt fails
      tryCatch({
        cat("    Attempting alternative reading method...\n")
        data <- read.csv(file, stringsAsFactors = FALSE)
        data <- as_tibble(data)
        data$PID <- pid
        data$device_type <- device_type
        
        # Add to the appropriate list
        absolute_data[[length(absolute_data) + 1]] <- data
        
        cat("    Successfully loaded with alternative method\n")
      }, error = function(e2) {
        cat("    Alternative method also failed:", e2$message, "\n")
      })
    })
  }
}

```

```{r clean_data, echo = FALSE, warning = FALSE, message = FALSE}
# Combine data for each test type
if (length(localization_data) > 0) {
  localization_combined <- bind_rows(localization_data)
  
  # Standardize column names - make sure we're using lowercase device_type
  # This handles any potential mixed-case issues in the source data
  if ("DeviceType" %in% names(localization_combined)) {
    localization_combined$device_type <- localization_combined$DeviceType
    localization_combined <- localization_combined %>% select(-DeviceType)
  } else if ("Device_Type" %in% names(localization_combined)) {
    localization_combined$device_type <- localization_combined$Device_Type
    localization_combined <- localization_combined %>% select(-Device_Type)
  }
  
  # Clean up device_type column
  localization_combined$device_type <- tolower(localization_combined$device_type)
  localization_combined$device_type <- ifelse(
    !localization_combined$device_type %in% c("bracelet", "necklace", "overear"),
    NA,
    localization_combined$device_type
  )
  
  # Remove rows with NA device types
  localization_combined <- localization_combined %>% filter(!is.na(device_type))
  
  # CRITICAL: Calculate Correct column for localization data
  localization_combined$Correct <- ifelse(
    localization_combined$Motor == localization_combined$Response, 1, 0
  )
  
  # Summary of device types
  cat("Device types distribution:\n")
  print(table(localization_combined$device_type, useNA = "ifany"))
  
  cat("Total localization data entries:", nrow(localization_combined), "\n")
} else {
  localization_combined <- NULL
  cat("No localization data found.\n")
}

if (length(two_point_data) > 0) {
  two_point_combined <- bind_rows(two_point_data)
  
  # Clean up Device_Type column
  two_point_combined$device_type <- tolower(two_point_combined$device_type)
  two_point_combined$device_type <- ifelse(
    !two_point_combined$device_type %in% c("bracelet", "necklace", "overear"),
    NA,
    two_point_combined$device_type
  )
  
  cat("Total two-point discrimination data entries:", nrow(two_point_combined), "\n")
} else {
  two_point_combined <- NULL
  cat("No two-point discrimination data found.\n")
}


#print unique pids
unique_pid_localization <- unique(localization_combined$PID)
#print list of unique pid
print(unique_pid_localization)




#print unique pids
unique_pid_tp <- unique(two_point_combined$PID)
#print list of unique pid
print(unique_pid_tp)


```

## Localization Accuracy Analysis

```{r localization_analysis, echo = FALSE, warning = FALSE, message = FALSE}

# Double-check that we have Correct column
if (!is.null(localization_combined) && !"Correct" %in% names(localization_combined)) {
  localization_combined$Correct <- ifelse(
    localization_combined$Motor == localization_combined$Response, 1, 0
  )
}

# Accuracy by motor position for each device type
accuracy_by_motor <- localization_combined %>%
  group_by(device_type, Motor) %>%
  summarise(
    Accuracy = mean(Correct, na.rm = TRUE),
    SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
    n = n()
  )

# Plot accuracy by motor position for each device
ggplot(accuracy_by_motor, aes(x = Motor, y = Accuracy, color = device_type)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = Accuracy - SE, ymax = Accuracy + SE), width = 0.2) +
  scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
  labs(
    title = "Localization Accuracy by Motor Position",
    x = "Motor Position",
    y = "Average Accuracy"
  ) +
  facet_wrap(~ device_type) +
  my_theme

# First, check how many rows have NA device types
na_device_count <- sum(is.na(localization_combined$device_type))
cat("Number of rows with NA device_type:", na_device_count, "\n")

# Make sure all three device types are considered, even if they don't appear in the data
expected_devices <- c("bracelet", "necklace", "overear")
existing_devices <- unique(localization_combined$device_type[!is.na(localization_combined$device_type)])
devices <- unique(c(expected_devices, existing_devices))

cat("Device types to process:", paste(devices, collapse=", "), "\n")

# Process each device type
for (device in devices) {
  # This ensures we only process valid device types
  device_data <- localization_combined %>% 
    filter(device_type == device)
  
  cat("\n=====================================\n")
  cat("DEVICE:", device, "\n")
  cat("=====================================\n")
  cat("Number of rows for this device:", nrow(device_data), "\n")
  
  # Only proceed if we have data
  if (nrow(device_data) > 0) {
    # Get all unique values from both Motor and Response
    all_levels <- sort(unique(c(device_data$Motor, device_data$Response)))
    
    # Create factors with the same levels
    device_data$Motor_factor <- factor(device_data$Motor, levels = all_levels)
    device_data$Response_factor <- factor(device_data$Response, levels = all_levels)
    
    # Show the confusion matrix
    cat("\nConfusion Matrix for", device, "device:\n")
    
    # Use tryCatch to handle potential errors
    tryCatch({
      confusion <- confusionMatrix(data = device_data$Response_factor,
                                  reference = device_data$Motor_factor)
      print(confusion)
      
      # Visualize confusion matrix
      conf_mat <- as.data.frame(confusion$table)
      conf_mat_wide <- dcast(conf_mat, Prediction ~ Reference, value.var = "Freq")
      conf_mat_matrix <- as.matrix(conf_mat_wide[, -1])
      rownames(conf_mat_matrix) <- conf_mat_wide$Prediction
      
      # Normalize by reference (true) class
      conf_mat_norm <- sweep(conf_mat_matrix, 2, colSums(conf_mat_matrix), "/")
      
      # Convert to long format for ggplot
      conf_mat_long <- melt(conf_mat_norm)
      colnames(conf_mat_long) <- c("Predicted", "Actual", "Proportion")
      
      # Create heatmap visualization
      p <- ggplot(conf_mat_long, aes(x = Actual, y = Predicted, fill = Proportion)) +
        geom_tile() +
        geom_text(aes(label = sprintf("%.2f", Proportion)), size = 3) +
        scale_fill_gradient(low = "white", high = "blue") +
        #the labels are 1 through 6 starting from the bottom left cell
        labs(
          title = paste("Confusion Matrix -", device, "Device"),
          x = "Actual Motor Position",
          y = "Predicted Motor Position",
          fill = "Proportion"
        ) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_x_discrete(limits = rev(levels(conf_mat_long$Actual))) +
        scale_y_discrete(limits = levels(conf_mat_long$Predicted))
      
      print(p)
        
    }, error = function(e) {
      cat("Error creating confusion matrix for", device, "device:", e$message, "\n")
      cat("Falling back to base R table method\n")
      
      # Create a simple confusion matrix using table()
      conf_table <- table(Predicted = device_data$Response, Actual = device_data$Motor)
      print(conf_table)
      
      # Calculate accuracy manually
      accuracy <- sum(diag(conf_table)) / sum(conf_table)
      cat("Accuracy:", round(accuracy * 100, 2), "%\n")
      
      # Visualize using the raw table
      conf_norm <- prop.table(conf_table, margin = 2)  # Normalize by column (actual)
      conf_norm_df <- as.data.frame(conf_norm)
      names(conf_norm_df) <- c("Predicted", "Actual", "Proportion")
      
      # Create heatmap visualization with base R table
      p <- ggplot(conf_norm_df, aes(x = Actual, y = Predicted, fill = Proportion)) +
        geom_tile() +
        geom_text(aes(label = sprintf("%.2f", Proportion)), size = 3) +
        scale_fill_gradient(low = "white", high = "blue") +
        labs(
          title = paste("Confusion Matrix -", device, "Device"),
          x = "Actual Motor Position",
          y = "Predicted Motor Position",
          fill = "Proportion"
        ) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
      
      print(p)
    })
    
    # Display data distribution for this device
    cat("\nMotor distribution for", device, "device:\n")
    print(table(device_data$Motor))
    
    cat("\nResponse distribution for", device, "device:\n")
    print(table(device_data$Response))
    
  } else {
    cat("No data available for device type:", device, "\n")
  }
}

# Accuracy by participant
accuracy_by_participant <- localization_combined %>%
  group_by(PID, device_type) %>%
  summarise(
    Accuracy = mean(Correct, na.rm = TRUE),
    n = n()
  )

# Filter out any incorrect device types
accuracy_by_participant <- accuracy_by_participant %>%
  filter(device_type %in% c("bracelet", "necklace", "overear"))

# Clean up device_type to ensure consistent naming
accuracy_by_participant$device_type <- tolower(accuracy_by_participant$device_type)

# Visualize accuracy by participant
ggplot(accuracy_by_participant, aes(x = factor(PID), y = Accuracy, fill = device_type)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
  scale_fill_manual(values = c("bracelet" = "#8B5A00", "necklace" = "#008B45", "overear" = "#00688B")) +
  labs(
    title = "Localization Accuracy by Participant",
    x = "Participant ID",
    y = "Average Accuracy"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

## Two-Point Discrimination Analysis

```{r two_point_analysis, echo = FALSE, warning = FALSE, message = FALSE}
if (!is.null(two_point_combined)) {
  # Ensure data types are correct
  two_point_combined$FirstMotor <- as.numeric(two_point_combined$FirstMotor)
  two_point_combined$SecondMotor <- as.numeric(two_point_combined$SecondMotor)
  two_point_combined$Correct <- as.numeric(two_point_combined$Correct)
  
  # Overall accuracy
  overall_accuracy <- mean(two_point_combined$Correct, na.rm = TRUE)
  cat("Overall two-point discrimination accuracy:", round(overall_accuracy * 100, 2), "%\n")
  
  # Accuracy by device type
  accuracy_by_device <- two_point_combined %>%
    filter(device_type %in% c("bracelet", "necklace", "overear")) %>%
    group_by(device_type) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
      n = n()
    )
  
  cat("\nTwo-point discrimination accuracy by device type:\n")
  print(accuracy_by_device)
  
  # Plot accuracy by device type
  ggplot(accuracy_by_device, aes(x = device_type, y = Accuracy, fill = device_type)) +
    geom_bar(stat = "identity") +
    geom_errorbar(aes(ymin = Accuracy - SE, ymax = Accuracy + SE), width = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    scale_fill_manual(values = c("bracelet" = "#8B5A00", "necklace" = "#008B45", "overear" = "#00688B")) +
    labs(
      title = "Two-Point Discrimination Accuracy by Device Type",
      x = "Device Type",
      y = "Average Accuracy"
    ) +
    my_theme
  
  # Calculate distance between motors
  two_point_combined$Distance <- abs(two_point_combined$FirstMotor - two_point_combined$SecondMotor)
  
  # Accuracy by distance between motors
  accuracy_by_distance <- two_point_combined %>%
    group_by(device_type, Distance) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
      n = n()
    )
  
  # Plot accuracy by distance
  ggplot(accuracy_by_distance, aes(x = Distance, y = Accuracy, color = device_type)) +
    geom_point(size = 3) +
    geom_line(aes(group = device_type)) +
    geom_errorbar(aes(ymin = Accuracy - SE, ymax = Accuracy + SE), width = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(
      title = "Two-Point Discrimination Accuracy by Motor Distance",
      x = "Distance Between Motors",
      y = "Average Accuracy"
    ) +
    facet_wrap(~ device_type) +
    my_theme
  
  # Accuracy by first motor position
  accuracy_by_first_motor <- two_point_combined %>%
    group_by(device_type, FirstMotor) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      SE = sd(Correct, na.rm = TRUE) / sqrt(n()),
      n = n()
    )
  
  # Plot accuracy by first motor position
  ggplot(accuracy_by_first_motor, aes(x = FirstMotor, y = Accuracy, color = device_type)) +
    geom_point(size = 3) +
    geom_line(aes(group = device_type)) +
    geom_errorbar(aes(ymin = Accuracy - SE, ymax = Accuracy + SE), width = 0.2) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(
      title = "Two-Point Discrimination Accuracy by First Motor Position",
      x = "First Motor Position",
      y = "Average Accuracy"
    ) +
    facet_wrap(~ device_type) +
    my_theme
  
  # Accuracy by participant
  accuracy_by_participant <- two_point_combined %>%
    group_by(PID, device_type) %>%
    summarise(
      Accuracy = mean(Correct, na.rm = TRUE),
      n = n()
    )
  
  # Visualize accuracy by participant
  ggplot(accuracy_by_participant, aes(x = PID, y = Accuracy, fill = device_type)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(
      title = "Two-Point Discrimination Accuracy by Participant",
      x = "Participant ID",
      y = "Average Accuracy"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
}
```

## Absolute Threshold Analysis

```{r absolute_threshold_analysis, echo = FALSE, warning = FALSE, message = FALSE}

# Function to find header row and transform data properly
find_header_and_transform <- function(df) {
  header_row <- which(df[,1] == "Timestamp")
  
  if(length(header_row) == 0) {
    for(i in 1:ncol(df)) {
      header_candidates <- which(df[,i] == "Timestamp")
      if(length(header_candidates) > 0) {
        header_row <- header_candidates[1]
        break
      }
    }
  }
  
  if(length(header_row) == 0) {
    return(NULL)  # Return NULL if no header found
  }
  
  names(df) <- as.character(df[header_row,])
  df <- df[(header_row+1):nrow(df),]
  rownames(df) <- NULL
  return(df)
}

# Function to extract device type
get_device_type <- function(df, filename) {
  if("DeviceType" %in% names(df)) {
    device_types <- unique(df$DeviceType[!is.na(df$DeviceType)])
    if(length(device_types) > 0) {
      return(device_types[1])
    }
  }
  
  device_keywords <- c("bracelet", "necklace", "overear")
  for(keyword in device_keywords) {
    for(col in names(df)) {
      if(is.character(df[[col]]) || is.factor(df[[col]])) {
        if(any(grepl(keyword, df[[col]], ignore.case = TRUE))) {
          return(keyword)
        }
      }
    }
  }
  
  for(keyword in device_keywords) {
    if(grepl(keyword, filename, ignore.case = TRUE)) {
      return(keyword)
    }
  }
  
  return("Unknown Device")
}

# Set folder path
base_folder <- "~/Desktop/[HapticHearing] Data/"
participant_folders <- list.dirs(path = base_folder, full.names = TRUE, recursive = FALSE)

# Initialize empty list to store data
data_list <- list()

# Process each participant folder
for (participant_folder in participant_folders) {
  pid <- basename(participant_folder)
  absolute_folder <- participant_folder  # Look directly in participant's folder
  
  if (!dir.exists(absolute_folder)) {
    next  # Skip if Absolute folder does not exist
  }
  
  csv_files <- list.files(path = absolute_folder, pattern = "absolute_threshold_.*\\.csv$|Absolute.*\\.csv$", full.names = TRUE, ignore.case = TRUE)
  
  for (csv_file in csv_files) {
    df <- read.csv(csv_file, header = FALSE, fill = TRUE, stringsAsFactors = FALSE)
    df <- find_header_and_transform(df)
    
    if (!is.null(df)) {
      device_type <- get_device_type(df, csv_file)
      df$PID <- pid
      df$device_type <- device_type
      data_list[[length(data_list) + 1]] <- df
    }
  }
}

# Verify loaded datasets
cat("Loaded", length(data_list), "datasets\n")

# Initialize threshold_results as empty dataframe with correct structure
threshold_results <- data.frame(
  PID = character(),
  device_type = character(),
  Actuator = character(),
  Threshold = numeric(),
  stringsAsFactors = FALSE
)

# Now process each dataset separately
for (i in seq_along(data_list)) {
  df <- data_list[[i]]
  
  device_type <- unique(df$device_type)
  pid <- unique(df$PID)
  cat("\nProcessing participant", pid, "with device", device_type, "\n")
  
  # Ensure necessary columns exist
  required_columns <- c("Actuator", "Amplitude", "Correct", "IsReversal")
  missing_columns <- setdiff(required_columns, names(df))
  if (length(missing_columns) > 0) {
    cat("Skipping dataset due to missing columns:", paste(missing_columns, collapse = ", "), "\n")
    next
  }

  # Ensure numeric types for critical columns
  df$Amplitude <- as.numeric(df$Amplitude)
  
  # Convert Type column to uppercase if it exists
  if("Type" %in% names(df)) {
    df$Type <- toupper(as.character(df$Type))
    # Filter for GUESS rows only if Type column exists
    df <- df %>% filter(Type == "GUESS")
  }
  
  # Filter out data with missing actuator info or empty actuator values
  df <- df %>% 
    filter(!is.na(Actuator) & Actuator != "" & !is.null(Actuator))
  
  # Get unique actuators
  actuators <- unique(df$Actuator)
  actuator_thresholds <- list()
  actuator_plots <- list()
  
  for (actuator in actuators) {
    # Subset data for this actuator
    actuator_data <- df %>% filter(Actuator == actuator)
    
    # Skip actuators with too few trials
    if (nrow(actuator_data) < 5) {
      cat("Skipping actuator", actuator, "with only", nrow(actuator_data), "trials\n")
      next
    }
    
    actuator_data$Trial <- seq_len(nrow(actuator_data))
    
    # Improved reversal detection - try multiple approaches
    # First, look for TRUE values in IsReversal column
    reversal_rows <- tryCatch({
      if (is.logical(actuator_data$IsReversal)) {
        actuator_data %>% filter(IsReversal == TRUE)
      } else if (is.character(actuator_data$IsReversal)) {
        actuator_data %>% filter(toupper(IsReversal) %in% c("TRUE", "T", "YES", "Y"))
      } else {
        # If IsReversal is numeric, treat non-zero as TRUE
        actuator_data %>% filter(as.numeric(IsReversal) != 0)
      }
    }, error = function(e) {
      # Fallback method: look for amplitude direction changes
      actuator_data$diff <- c(0, diff(actuator_data$Amplitude))
      actuator_data$diff_sign <- sign(actuator_data$diff)
      actuator_data$sign_change <- c(0, abs(diff(actuator_data$diff_sign)))
      reversal_indices <- which(actuator_data$sign_change == 2)
      if (length(reversal_indices) > 0) {
        actuator_data[reversal_indices, ]
      } else {
        data.frame()  # Empty dataframe if no reversals found
      }
    })
    
    reversal_count <- nrow(reversal_rows)
    cat("  Actuator", actuator, "has", reversal_count, "reversal points\n")
    
    incorrect_data <- tryCatch({
      if (is.logical(actuator_data$Correct)) {
        actuator_data %>% filter(Correct == FALSE)
      } else if (is.character(actuator_data$Correct)) {
        actuator_data %>% filter(toupper(Correct) %in% c("FALSE", "F", "NO", "N"))
      } else {
        # If Correct is numeric, treat zero as FALSE
        actuator_data %>% filter(as.numeric(Correct) == 0)
      }
    }, error = function(e) {
      data.frame()  # Empty dataframe if error
    })
    
    # Compute threshold (average of last 4 reversals or all if fewer)
    if (reversal_count >= 4) {
      # Make sure we use the last 4 reversals by sorting first
      reversal_rows <- reversal_rows %>% arrange(Trial)
      last_four <- tail(reversal_rows, 4)
      avg_value <- mean(last_four$Amplitude, na.rm = TRUE)
      cat("    Using last 4 reversals. Amplitudes:", paste(last_four$Amplitude, collapse=", "), "\n")
      cat("    Calculated threshold:", avg_value, "\n")
    } else if (reversal_count > 0) {
      avg_value <- mean(reversal_rows$Amplitude, na.rm = TRUE)
      cat("    Using all available reversals. Amplitudes:", paste(reversal_rows$Amplitude, collapse=", "), "\n")
      cat("    Calculated threshold:", avg_value, "\n")
    } else {
      avg_value <- NA
      cat("    No reversals found - threshold cannot be calculated\n")
    }
    
    actuator_thresholds[[as.character(actuator)]] <- avg_value
    
      # Create plot
    p <- ggplot(actuator_data, aes(x = Trial, y = Amplitude, group = 1)) +  # Ensure group=1 for connecting trials
      geom_line(color = "black") +  # Line connecting trials
      geom_point(size = 3) +  # All points
      labs(
        title = paste("Amplitude vs Trial:", device_type, "- Actuator", actuator, "- PID", pid),
        x = "Trial",
        y = "Amplitude",
        color = NULL,
        caption = paste0("Final Reversals Avg: ", ifelse(!is.na(avg_value), round(avg_value, 4), "N/A"))
      ) + theme_minimal()
    
    # Add reversal points first (so they'll be on the bottom layer)
    if (reversal_count > 0) {
      p <- p + geom_point(data = reversal_rows, aes(color = "Reversal"), size = 4, shape = 17)
    }
    
    # Add incorrect points on top with smaller size and red color
    if (nrow(incorrect_data) > 0) {
      p <- p + geom_point(data = incorrect_data, aes(color = "Incorrect"), size = 2.5, shape = 16)
    }
    
    # Add threshold line if available
    if (!is.na(avg_value)) {
      p <- p + geom_hline(yintercept = avg_value, color = "blue", linetype = "dashed", size = 1)
    }
    
    # Add color scale with red for incorrect and light blue for reversals
    p <- p + scale_color_manual(values = c("Incorrect" = "red", "Reversal" = "blue"))
    
    # Store for later combined plotting
    actuator_plots[[as.character(actuator)]] <- actuator_data
    
    # Print individual actuator plot
    print(p)
    # Add to threshold results
    threshold_results <- rbind(threshold_results, data.frame(
      PID = pid,
      device_type = device_type,
      Actuator = as.character(actuator),
      Threshold = avg_value,
      stringsAsFactors = FALSE
    ))
  }
  
  # Create separate colorful overlay graph for each participant-device
  if (length(actuator_plots) > 0) {
    combined_data <- do.call(rbind, actuator_plots)
    overlay_title <- paste("Amplitude vs Trial (All Actuators) - Device:", device_type, "- PID", pid)
    overlay_plot <- ggplot(combined_data, aes(x = Trial, y = Amplitude, color = factor(Actuator))) +
      geom_line() +
      geom_point(size = 1) +
      labs(title = overlay_title, x = "Trial", y = "Amplitude", color = "Actuator") +
      theme_minimal()
    print(overlay_plot)
  }
}

# Filter out NA thresholds for plotting
threshold_results_filtered <- threshold_results %>% filter(!is.na(Threshold))
cat("\nFinal threshold results summary (filtered):\n")
print(head(threshold_results_filtered))

# Create separate threshold summary graphs for each device type
for (device in unique(threshold_results_filtered$device_type)) {
  device_data <- threshold_results_filtered %>% filter(device_type == device)
  
  # Skip if there aren't enough data points
  if (nrow(device_data) < 2) {
    cat("Skipping summary plot for device", device, "- not enough data points\n")
    next
  }
  
p <- ggplot(device_data, aes(x = Actuator, y = Threshold)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  labs(title = paste("Threshold Distribution by Actuator for Device:", device), 
       x = "Actuator", 
       y = "Threshold") +
   geom_jitter(width = 0.01, height = 0, alpha = 0.7, color = "black", size = 1) +
  theme_minimal()
print(p)}

# Summary stats by device type
cat("\nSummary statistics by device type:\n")
device_summary <- threshold_results_filtered %>%
  group_by(device_type) %>%
  summarise(
    Mean_Threshold = mean(Threshold, na.rm = TRUE),
    SD = sd(Threshold, na.rm = TRUE),
    Min = min(Threshold, na.rm = TRUE),
    Max = max(Threshold, na.rm = TRUE),
    N = n()
  )
print(device_summary)

# Create device comparison plot
ggplot(device_summary, aes(x = device_type, y = Mean_Threshold, fill = device_type)) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin = Mean_Threshold - SD, ymax = Mean_Threshold + SD), width = 0.2) +
  labs(title = "Average Threshold by Device Type",
       x = "Device Type",
       y = "Mean Threshold") +
  theme_bw()+
  theme_minimal()

all_device_data <- threshold_results_filtered

# Create improved horizontal plot
# This approach will group boxplots by actuator number, with device types side by side

# Ensure Actuator is treated as a factor for proper ordering
all_device_data$Actuator <- factor(all_device_data$Actuator)
all_device_data$device_type <- factor(all_device_data$device_type, 
                                     levels = c("bracelet", "necklace", "overear"))

# Create a position variable for proper grouping and spacing
all_device_data$position <- as.numeric(all_device_data$Actuator) + 
  (as.numeric(factor(all_device_data$device_type, levels = c("bracelet", "necklace", "overear"))) - 2) * 0.3

# Create the improved horizontal plot
improved_horizontal <- ggplot(all_device_data, aes(x = position, y = Threshold, fill = device_type)) +
  geom_boxplot(width = 0.25) +
  scale_fill_manual(values = c("bracelet" = "#E69F00", "necklace" = "#56B4E9", "overear" = "#009E73"),
                    name = "Device Type") +
  # Add custom x-axis breaks and labels for actuator groups
  scale_x_continuous(
    breaks = 1:6,  # Centers of actuator groups
    labels = c("0", "1", "2", "3", "4", "5"),
    sec.axis = dup_axis(name = NULL, labels = NULL)  # Add top axis line
  ) +
  labs(title = "Threshold Distribution by Actuator and Device Type",
       x = "Actuator",
       y = "Threshold") +
  # Add vertical separators between actuator groups
  geom_vline(xintercept = 1.5:5.5, linetype = "dashed", color = "gray85") +
  theme_minimal() +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),  # Remove vertical grid lines
    panel.border = element_rect(fill = NA, color = "gray90"),
    plot.margin = margin(20, 20, 20, 20)
  )

# Print the improved horizontal plot
print(improved_horizontal)

# Alternative approach - using interaction() for grouping
# This may yield better spacing control
improved_horizontal_alt <- ggplot(all_device_data, 
                               aes(x = interaction(Actuator, sep=""), 
                                   y = Threshold, 
                                   fill = device_type)) +
  geom_boxplot(position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("bracelet" = "#E69F00", "necklace" = "#56B4E9", "overear" = "#009E73"),
                    name = "Device Type") +
  labs(title = "Threshold Distribution by Actuator and Device Type",
       x = "Actuator",
       y = "Threshold") +
  theme_minimal() +
  geom_jitter(width = 0.01, height = 0, alpha = 0.7, color = "black", size = 1) +
  theme(
    legend.position = "top",
    legend.title = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    plot.margin = margin(20, 20, 20, 20)
  )

print(improved_horizontal_alt)

# Third approach - using facet_grid for a more organized layout
improved_horizontal_facet <- ggplot(all_device_data, 
                                 aes(x = device_type, y = Threshold, fill = device_type)) +
  geom_boxplot() +
  facet_grid(. ~ Actuator, switch = "x") +  # Actuators on x-axis
  scale_fill_manual(values = c("bracelet" = "#E69F00", "necklace" = "#56B4E9", "overear" = "#009E73"),
                    name = "Device Type") +
  labs(title = "Threshold Distribution by Actuator and Device Type",
       x = "",  # Remove redundant x-axis title
       y = "Threshold") +
  theme_minimal() +
  theme(
    legend.position = "top",
    strip.placement = "outside",
    strip.background = element_rect(fill = "gray90"),
    strip.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title = element_text(size = 12),
    panel.spacing = unit(1, "lines"),
    panel.grid.minor = element_blank(),
    plot.margin = margin(20, 20, 20, 20)
  )

print(improved_horizontal_facet)




```



```{r device actuator pairs, echo = FALSE, warning = FALSE, message = FALSE}

# Before combining the data, we need to reset trial numbers by actuator for each participant

# Process each dataset to extract and normalize trajectory information
normalized_trajectory_data <- data.frame()

for (i in seq_along(data_list)) {
  df <- data_list[[i]]
  
  # Skip datasets without required columns
  required_columns <- c("Actuator", "Amplitude")
  missing_columns <- setdiff(required_columns, names(df))
  if (length(missing_columns) > 0) {
    next
  }
  
  # Ensure we have device type and PID
  if (!"device_type" %in% names(df) || !"PID" %in% names(df)) {
    next
  }
  
  # Filter out NA or invalid actuators
  df <- df %>% 
    filter(!is.na(Actuator) & Actuator != "" & !is.null(Actuator))
  
  # Reset trial numbers for each participant-actuator combination
  df <- df %>%
    group_by(PID, device_type, Actuator) %>%
    mutate(
      OriginalTrial = if("Trial" %in% names(.)) Trial else row_number(),
      Trial = row_number() # Reset trial numbers starting at 1
    ) %>%
    ungroup()
  
  # Add to combined dataset
  normalized_trajectory_data <- rbind(normalized_trajectory_data, df)
}

# Ensure Amplitude is numeric
normalized_trajectory_data$Amplitude <- as.numeric(normalized_trajectory_data$Amplitude)
normalized_trajectory_data$Actuator <- as.character(normalized_trajectory_data$Actuator)

# Get all unique device-actuator combinations
device_types <- c("bracelet", "necklace", "overear")
actuator_list <- 0:5  # Assuming actuators are numbered 0-5

# Create trajectory plots for each device-actuator combination
for (device in device_types) {
  for (actuator in actuator_list) {
    # Filter data for this device-actuator combination
    combo_data <- normalized_trajectory_data %>%
      filter(device_type == device, Actuator == actuator)
    
    # Skip if no data for this combination
    if (nrow(combo_data) == 0) {
      cat("No data for device:", device, "actuator:", actuator, "\n")
      next
    }
    
    # Calculate number of unique participants
    participants <- unique(combo_data$PID)
    num_participants <- length(participants)
    
    # Create the plot with reset trial numbers
    p <- ggplot(combo_data, aes(x = Trial, y = Amplitude, group = PID, color = PID)) +
      geom_line() +
      geom_point(size = 1) +
      labs(
        title = paste("All Participants:", device, "- Actuator", actuator),
        subtitle = paste(num_participants, "participants"),
        x = "Trial (reset per actuator)",
        y = "Amplitude",
        color = "Participant ID"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 14, hjust = 0.5),
        legend.position = "right"
      )
    
    # Display the plot
    print(p)
    
    # Create a second version with standardized trial numbers
    # This helps compare trajectory shapes when trial counts differ
    if (num_participants > 1) {
      # Normalize trial progression for each participant (0 to 1)
      normalized_data <- combo_data %>%
        group_by(PID) %>%
        mutate(
          MaxTrial = max(Trial),
          NormalizedTrial = Trial / MaxTrial
        ) %>%
        ungroup()
      
      p2 <- ggplot(normalized_data, aes(x = NormalizedTrial, y = Amplitude, group = PID, color = PID)) +
        geom_line() +
        geom_point(size = 1) +
        labs(
          title = paste("Normalized Trajectories:", device, "- Actuator", actuator),
          subtitle = paste(num_participants, "participants"),
          x = "Normalized Trial Position (0-1)",
          y = "Amplitude",
          color = "Participant ID"
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, hjust = 0.5),
          legend.position = "right"
        )
      
      # Display the normalized plot
      print(p2)
    }
  }
}

# For the average trajectories, we also need to use the reset trial numbers
avg_trajectories <- normalized_trajectory_data %>%
  # Normalize trial progression for each participant-device-actuator combination
  group_by(PID, device_type, Actuator) %>%
  mutate(
    MaxTrial = max(Trial),
    TrialPercent = floor((Trial / MaxTrial) * 10) / 10  # Round to nearest 0.1
  ) %>%
  ungroup() %>%
  # Calculate average amplitude at each trial percentage point
  group_by(device_type, Actuator, TrialPercent) %>%
  summarise(
    AvgAmplitude = mean(Amplitude, na.rm = TRUE),
    StdDev = sd(Amplitude, na.rm = TRUE),
    n = n(),
    .groups = 'drop'
  )

# Plot average trajectories for each device type
for (device in device_types) {
  device_data <- avg_trajectories %>% filter(device_type == device)
  
  # Skip if no data
  if (nrow(device_data) == 0) next
  
  p <- ggplot(device_data, aes(x = TrialPercent, y = AvgAmplitude, color = factor(Actuator), group = Actuator)) +
    geom_line(size = 1) +
    geom_point() +
    # Add error ribbons
    geom_ribbon(aes(ymin = AvgAmplitude - StdDev, ymax = AvgAmplitude + StdDev, fill = factor(Actuator)), alpha = 0.2, color = NA) +
    labs(
      title = paste("Average Trajectories by Actuator for", device),
      x = "Normalized Trial Position",
      y = "Average Amplitude",
      color = "Actuator",
      fill = "Actuator"
    ) +
    theme_minimal()
  
  print(p)
}
```



## Statistical Tests

#Absolute 


```{r absolute_threshold_stats, echo = FALSE, warning = FALSE, message = FALSE}
# First, inspect the threshold_results_filtered to understand its structure
str(threshold_results_filtered)

# Check for potential list columns that need to be converted
list_cols <- sapply(threshold_results_filtered, is.list)
if(any(list_cols)) {
  cat("Warning: Found list columns that need to be unpacked:", 
      paste(names(threshold_results_filtered)[list_cols], collapse=", "), "\n")
  
  # Try to unpack list columns
  for(col in names(threshold_results_filtered)[list_cols]) {
    cat("Unpacking list column:", col, "\n")
    # If it's a simple list of length 1 elements, try to unlist
    try({
      threshold_results_filtered[[col]] <- unlist(threshold_results_filtered[[col]])
      cat("Successfully unpacked", col, "\n")
    }, silent = TRUE)
  }
}

# Ensure all numeric columns are properly formatted
threshold_results_filtered$Threshold <- as.numeric(as.character(threshold_results_filtered$Threshold))
threshold_results_filtered$Actuator <- as.character(threshold_results_filtered$Actuator)

threshold_results_filtered$bracelet <- unlist(threshold_results_filtered$bracelet)
threshold_results_filtered$necklace <- unlist(threshold_results_filtered$necklace)
threshold_results_filtered$overear <- unlist(threshold_results_filtered$overear)


threshold_results_filtered$Threshold <- unlist(threshold_results_filtered$Threshold)


# Check for NA values introduced during conversion
na_counts <- sapply(threshold_results_filtered, function(x) sum(is.na(x)))
cat("NA counts after conversion:", paste(names(na_counts), na_counts, sep="=", collapse=", "), "\n")

# Reshape data to wide format with better error handling
tryCatch({
  # Print first few rows of the input data
  cat("First few rows of threshold_results_filtered:\n")
  print(head(threshold_results_filtered))
  
  # Reshape data to wide format for paired tests
  threshold_wide <- tidyr::pivot_wider(
    threshold_results_filtered,
    id_cols = c(PID, Actuator),
    names_from = device_type,
    values_from = Threshold
  )
  
  # Print first few rows of wide data
  cat("\nFirst few rows of threshold_wide:\n")
  print(head(threshold_wide))
  
  # Check for missing values and remove rows with NAs to enable paired tests
  threshold_wide_complete <- na.omit(threshold_wide)
  
  # Print first few rows of complete data
  cat("\nFirst few rows of threshold_wide_complete:\n")
  print(head(threshold_wide_complete))
  
  # Ensure all columns are numeric
  threshold_wide_complete$bracelet <- as.numeric(as.character(threshold_wide_complete$bracelet))
  threshold_wide_complete$necklace <- as.numeric(as.character(threshold_wide_complete$necklace))
  threshold_wide_complete$overear <- as.numeric(as.character(threshold_wide_complete$overear))
  
  # Check data structure before proceeding
  cat("\nStructure of threshold_wide_complete:\n")
  print(str(threshold_wide_complete))
  
  # Now it's safe to proceed with the statistical tests
  if(nrow(threshold_wide_complete) >= 3) {
    cat("\nRunning Shapiro-Wilk tests for normality:\n")
    tryCatch({
      # Calculate differences explicitly
      bn_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$necklace
      bo_diff <- threshold_wide_complete$bracelet - threshold_wide_complete$overear
      no_diff <- threshold_wide_complete$necklace - threshold_wide_complete$overear
      
      # Check for NA or NaN values
      cat("NA/NaN counts in differences: bn=", sum(is.na(bn_diff)), 
          ", bo=", sum(is.na(bo_diff)), 
          ", no=", sum(is.na(no_diff)), "\n")
      
      # Run tests
      if(sum(!is.na(bn_diff)) >= 3) print(shapiro.test(na.omit(bn_diff)))
      if(sum(!is.na(bo_diff)) >= 3) print(shapiro.test(na.omit(bo_diff)))
      if(sum(!is.na(no_diff)) >= 3) print(shapiro.test(na.omit(no_diff)))
    }, error = function(e) {
      cat("Error in Shapiro-Wilk tests:", e$message, "\n")
    })
  } else {
    cat("Not enough complete data for Shapiro-Wilk tests\n")
  }
  
  # Create data frame for repeated measures ANOVA
  cat("\nPreparing data for repeated measures ANOVA\n")
  threshold_long <- tidyr::pivot_longer(
    threshold_wide_complete,
    cols = c("bracelet", "necklace", "overear"),
    names_to = "device_type",
    values_to = "Threshold"
  )
  
  
  
  # Run ANOVA if there's enough data
  if(nrow(threshold_long) >= 5 && length(unique(threshold_long$PID)) >= 2) {
    cat("\nRunning repeated measures ANOVA\n")
    tryCatch({
      aov_model <- aov(Threshold ~ device_type + Error(PID/device_type), data = threshold_long)
      print(summary(aov_model))
    }, error = function(e) {
      cat("Error in ANOVA:", e$message, "\n")
    })
  } else {
    cat("Not enough data for repeated measures ANOVA\n")
  }
  
  # Only run t-tests if we have enough data
  if(nrow(threshold_wide_complete) >= 2) {
    cat("\nRunning paired t-tests\n")
    # Initialize results dataframe
    paired_results <- data.frame(
      Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
      t_value = NA,
      p_value = NA,
      p_adjusted = NA
    )
    
    # Run t-tests with error handling
    tryCatch({
      bn_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$necklace, paired = TRUE)
      bo_test <- t.test(threshold_wide_complete$bracelet, threshold_wide_complete$overear, paired = TRUE)
      no_test <- t.test(threshold_wide_complete$necklace, threshold_wide_complete$overear, paired = TRUE)
      
      # Compile results
      paired_results$t_value <- c(bn_test$statistic, bo_test$statistic, no_test$statistic)
      paired_results$p_value <- c(bn_test$p.value, bo_test$p.value, no_test$p.value)
      paired_results$p_adjusted <- p.adjust(paired_results$p_value, method = "bonferroni")
      
      # Print results
      print(paired_results)
    }, error = function(e) {
      cat("Error in paired t-tests:", e$message, "\n")
    })
  } else {
    cat("Not enough data for paired t-tests\n")
  }
  
  # Run non-parametric alternatives
  if(nrow(threshold_wide_complete) >= 2) {
    cat("\nRunning Wilcoxon signed-rank tests\n")
    # Initialize results dataframe
    wilcox_results <- data.frame(
      Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
      V_statistic = NA,
      p_value = NA,
      p_adjusted = NA
    )
    
    # Run tests with error handling
    tryCatch({
      bn_wilcox <- wilcox.test(threshold_wide_complete$bracelet, threshold_wide_complete$necklace, paired = TRUE)
      bo_wilcox <- wilcox.test(threshold_wide_complete$bracelet, threshold_wide_complete$overear, paired = TRUE)
      no_wilcox <- wilcox.test(threshold_wide_complete$necklace, threshold_wide_complete$overear, paired = TRUE)
      
      # Compile results
      wilcox_results$V_statistic <- c(bn_wilcox$statistic, bo_wilcox$statistic, no_wilcox$statistic)
      wilcox_results$p_value <- c(bn_wilcox$p.value, bo_wilcox$p.value, no_wilcox$p.value)
      wilcox_results$p_adjusted <- p.adjust(wilcox_results$p_value, method = "bonferroni")
      
      # Print results
      print(wilcox_results)
    }, error = function(e) {
      cat("Error in Wilcoxon tests:", e$message, "\n")
    })
  } else {
    cat("Not enough data for Wilcoxon tests\n")
  }
}, error = function(e) {
  cat("Error in data reshaping or analysis:", e$message, "\n")
  
  # Try to provide more detailed diagnostics
  cat("\nDiagnostics for troubleshooting:\n")
  cat("threshold_results_filtered class:", class(threshold_results_filtered), "\n")
  cat("threshold_results_filtered dimensions:", dim(threshold_results_filtered), "\n")
  cat("Column classes:\n")
  print(sapply(threshold_results_filtered, class))
})
```


## Absolute between motors: 

After bonferroni correction no significant differences between actuator. Before correction, necklace shows sifnificant difference between actuators.


```{r absolute_threshold_between_motors, echo = FALSE, warning = FALSE, message = FALSE}
# Check for differences between actuators for each device type
threshold_aov_actuator <- aov(Threshold ~ Actuator + Error(PID/Actuator), data = threshold_long)
summary(threshold_aov_actuator)

# You can also analyze by device type separately
for (device in unique(threshold_results_filtered$device_type)) {
  # Subset data for this device
  device_data <- threshold_results_filtered %>% 
    filter(device_type == device)
  
  # Convert to appropriate format
  device_data$PID <- factor(device_data$PID)
  device_data$Actuator <- factor(device_data$Actuator)
  
  # ANOVA for this device
  cat("\n\n=== Actuator differences for", device, "===\n")
  aov_model <- aov(Threshold ~ Actuator + Error(PID/Actuator), data = device_data)
  print(summary(aov_model))
  
  # Post-hoc tests if ANOVA is significant
  # Use pairwise t-tests
  if (length(unique(device_data$Actuator)) > 1) {
    actuator_means <- aggregate(Threshold ~ Actuator, data = device_data, FUN = mean)
    cat("\nMean thresholds by actuator:\n")
    print(actuator_means)
    
    # If there are enough data points, do pairwise comparisons
    if (length(unique(device_data$Actuator)) > 1) {
      cat("\nPairwise comparisons between actuators:\n")
      pairwise_result <- pairwise.t.test(
        device_data$Threshold, 
        device_data$Actuator,
        p.adjust.method = "bonferroni",
        paired = FALSE  # Change to TRUE if fully paired design
      )
      print(pairwise_result)
    }
  }
}
```

##Localization Accuracy Statistical Analysis

```{r localization_accuracy_stats, echo = FALSE, warning = FALSE, message = FALSE}

# Create participant-level summary data
loc_summary <- localization_combined %>%
  group_by(PID, device_type) %>%
  summarise(Accuracy = mean(Correct, na.rm = TRUE)) %>%
  ungroup()

# Convert to wide format
loc_wide <- loc_summary %>%
  pivot_wider(
    id_cols = PID,
    names_from = device_type,
    values_from = Accuracy
  )

# Remove rows with missing values
loc_wide_complete <- na.omit(loc_wide)

# Test for normality
shapiro.test(loc_wide_complete$bracelet - loc_wide_complete$necklace)
shapiro.test(loc_wide_complete$bracelet - loc_wide_complete$overear)
shapiro.test(loc_wide_complete$necklace - loc_wide_complete$overear)

# Reshape for repeated measures
loc_long <- reshape(
  loc_wide_complete,
  idvar = "PID",
  varying = c("bracelet", "necklace", "overear"),
  v.names = "Accuracy",
  timevar = "device_type",
  times = c("bracelet", "necklace", "overear"),
  direction = "long"
)

# Repeated measures ANOVA
loc_aov <- aov(Accuracy ~ device_type + Error(PID/device_type), data = loc_long)
summary(loc_aov)

# Paired t-tests for post-hoc comparisons
loc_bn <- t.test(loc_wide_complete$bracelet, loc_wide_complete$necklace, paired = TRUE)
loc_bo <- t.test(loc_wide_complete$bracelet, loc_wide_complete$overear, paired = TRUE)
loc_no <- t.test(loc_wide_complete$necklace, loc_wide_complete$overear, paired = TRUE)

# Apply Bonferroni correction
loc_p_values <- c(loc_bn$p.value, loc_bo$p.value, loc_no$p.value)
loc_p_adjusted <- p.adjust(loc_p_values, method = "bonferroni")

# Print results
loc_results <- data.frame(
  Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
  t_value = c(loc_bn$statistic, loc_bo$statistic, loc_no$statistic),
  p_value = loc_p_values,
  p_adjusted = loc_p_adjusted
)
print(loc_results)
```

##Localization between motors 

```{r localization_motor_stats, echo = FALSE, warning = FALSE, message = FALSE}
# Test for differences between motor positions
# First, prepare the data
localization_for_motor <- localization_combined %>%
  mutate(
    Motor = factor(Motor),
    PID = factor(PID)
  )

# Run separate analysis for each device type
for (device in unique(localization_for_motor$device_type)) {
  device_data <- localization_for_motor %>% 
    filter(device_type == device)
  
  cat("\n\n=== Motor position effects for", device, "===\n")
  
  # Check if we have enough data
  if (nrow(device_data) > 0) {
    # ANOVA to test effect of motor position on accuracy
    aov_model <- aov(Correct ~ Motor + Error(PID/Motor), data = device_data)
    print(summary(aov_model))
    
    # Calculate and print accuracy by motor position
    motor_accuracy <- device_data %>%
      group_by(Motor) %>%
      summarize(
        Accuracy = mean(Correct, na.rm = TRUE),
        SD = sd(Correct, na.rm = TRUE),
        n = n()
      )
    
    cat("\nAccuracy by motor position:\n")
    print(motor_accuracy)
    
    # Pairwise comparisons if overall test is significant
    cat("\nPairwise comparisons between motor positions:\n")
    pairwise_result <- pairwise.t.test(
      device_data$Correct, 
      device_data$Motor,
      p.adjust.method = "bonferroni"
    )
    print(pairwise_result)
  } else {
    cat("Not enough data for analysis")
  }
}
```
## Two point accuracy 

```{r two_point_accuracy_stats, echo = FALSE, warning = FALSE, message = FALSE}
# Create participant-level summary data
tp_summary <- two_point_combined %>%
  group_by(PID, device_type) %>%
  summarise(Accuracy = mean(Correct, na.rm = TRUE)) %>%
  ungroup()

# Convert to wide format
tp_wide <- tp_summary %>%
  pivot_wider(
    id_cols = PID,
    names_from = device_type,
    values_from = Accuracy
  )

# Remove rows with missing values
tp_wide_complete <- na.omit(tp_wide)

# Test for normality
shapiro.test(tp_wide_complete$bracelet - tp_wide_complete$necklace)
shapiro.test(tp_wide_complete$bracelet - tp_wide_complete$overear)
shapiro.test(tp_wide_complete$necklace - tp_wide_complete$overear)

# Reshape for repeated measures
tp_long <- reshape(
  tp_wide_complete,
  idvar = "PID",
  varying = c("bracelet", "necklace", "overear"),
  v.names = "Accuracy",
  timevar = "device_type",
  times = c("bracelet", "necklace", "overear"),
  direction = "long"
)

# Repeated measures ANOVA
tp_aov <- aov(Accuracy ~ device_type + Error(PID/device_type), data = tp_long)
summary(tp_aov)

# Paired t-tests for post-hoc comparisons
tp_bn <- t.test(tp_wide_complete$bracelet, tp_wide_complete$necklace, paired = TRUE)
tp_bo <- t.test(tp_wide_complete$bracelet, tp_wide_complete$overear, paired = TRUE)
tp_no <- t.test(tp_wide_complete$necklace, tp_wide_complete$overear, paired = TRUE)

# Apply Bonferroni correction
tp_p_values <- c(tp_bn$p.value, tp_bo$p.value, tp_no$p.value)
tp_p_adjusted <- p.adjust(tp_p_values, method = "bonferroni")

# Print results
tp_results <- data.frame(
  Comparison = c("Bracelet vs Necklace", "Bracelet vs Overear", "Necklace vs Overear"),
  t_value = c(tp_bn$statistic, tp_bo$statistic, tp_no$statistic),
  p_value = tp_p_values,
  p_adjusted = tp_p_adjusted
)
print(tp_results)
```


## Two point between motors 

```{r two_point_motor_stats, echo = FALSE, warning = FALSE, message = FALSE}
  # For two-point discrimination, we want to analyze the effect of
# motor distance and possibly start position

# First approach: Effect of distance on accuracy
tp_distance_data <- two_point_combined %>%
  mutate(
    Distance = factor(abs(FirstMotor - SecondMotor)),
    PID = factor(PID)
  )

# Analyze by device type
for (device in unique(tp_distance_data$device_type)) {
  device_data <- tp_distance_data %>% 
    filter(device_type == device)
  
  cat("\n\n=== Effect of motor distance for", device, "===\n")
  
  if (nrow(device_data) > 0 && length(unique(device_data$Distance)) > 1) {
    # ANOVA
    aov_model <- aov(Correct ~ Distance + Error(PID/Distance), data = device_data)
    print(summary(aov_model))
    
    # Accuracy by distance
    distance_accuracy <- device_data %>%
      group_by(Distance) %>%
      summarize(
        Accuracy = mean(Correct, na.rm = TRUE),
        SD = sd(Correct, na.rm = TRUE),
        n = n()
      )
    
    cat("\nAccuracy by motor distance:\n")
    print(distance_accuracy)
    
    # Pairwise comparisons
    if (length(unique(device_data$Distance)) > 1) {
      cat("\nPairwise comparisons between distances:\n")
      pairwise_result <- pairwise.t.test(
        device_data$Correct, 
        device_data$Distance,
        p.adjust.method = "bonferroni"
      )
      print(pairwise_result)
    }
  } else {
    cat("Not enough data or variation in distances for analysis")
  }
  
  # Second approach: Effect of first motor position on accuracy
  cat("\n\n=== Effect of first motor position for", device, "===\n")
  
  device_data <- two_point_combined %>%
    filter(device_type == device) %>%
    mutate(
      FirstMotor = factor(FirstMotor),
      PID = factor(PID)
    )
  
  if (nrow(device_data) > 0 && length(unique(device_data$FirstMotor)) > 1) {
    # ANOVA
    aov_model <- aov(Correct ~ FirstMotor + Error(PID/FirstMotor), data = device_data)
    print(summary(aov_model))
    
    # Accuracy by first motor
    motor_accuracy <- device_data %>%
      group_by(FirstMotor) %>%
      summarize(
        Accuracy = mean(Correct, na.rm = TRUE),
        SD = sd(Correct, na.rm = TRUE),
        n = n()
      )
    
    cat("\nAccuracy by first motor position:\n")
    print(motor_accuracy)
    
    # Pairwise comparisons
    if (length(unique(device_data$FirstMotor)) > 1) {
      cat("\nPairwise comparisons between first motor positions:\n")
      pairwise_result <- pairwise.t.test(
        device_data$Correct, 
        device_data$FirstMotor,
        p.adjust.method = "bonferroni"
      )
      print(pairwise_result)
    }
  } else {
    cat("Not enough data or variation in first motor positions for analysis")
  }
}
```


#Questionaire Data 

```{r questionnaire_data, echo = FALSE, warning = FALSE, message = FALSE}

# Read the data
questionnaire_data <- read_csv("Desktop/HH_Qualtrics_TRUE_ACTUALLY_CLEANED.csv")

# Display the head of the data
head(questionnaire_data)

#remove first two rows from questionnaire_data
questionnaire_data <- questionnaire_data[-c(1,2),]

head(questionnaire_data)
# questionnaire_data$Q55 as numeric
questionnaire_data$Q55 <- as.numeric(questionnaire_data$Q55)

# questionnaire_data$Q58 as numeric
questionnaire_data$Q58 <- as.numeric(questionnaire_data$Q58)

print("mean neck measurement")
mean(questionnaire_data$Q55)

print("mean wrist measurement")
mean(questionnaire_data$Q58)

```


```{r neck_effect_analysis, warning = FALSE, message = FALSE}



# Display summary statistics for neck measurements
cat("Summary of neck measurements (Q55):\n")
summary(questionnaire_data$Q55)
cat("\nStandard deviation:", sd(questionnaire_data$Q55, na.rm = TRUE), "\n")

# Create histogram of neck measurements
ggplot(questionnaire_data, aes(x = Q55)) +
  geom_histogram(bins = 10, fill = "blue", alpha = 0.7) +
  labs(title = "Distribution of Neck Measurements", x = "Neck Circumference (cm)", y = "Count") +
  theme_minimal()

# Ensure PIDs are character type for joining
questionnaire_data$PID <- as.character(questionnaire_data$PID)

#-----------------------------------------------------------------
# DEVICE-SPECIFIC ANALYSIS
#-----------------------------------------------------------------

#-----------------------------------------------------------------
# 1. ABSOLUTE THRESHOLD ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== ABSOLUTE THRESHOLD ANALYSIS BY DEVICE ===\n")

# Merge threshold data with questionnaire data
threshold_with_neck <- threshold_results_filtered %>%
  inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")

# Check the merged dataset 
cat("\nRows in merged threshold data:", nrow(threshold_with_neck), "\n")

# Device-specific models for threshold data
for (device in unique(threshold_with_neck$device_type)) {
  device_data <- threshold_with_neck %>% filter(device_type == device)
  
  cat("\n--- Absolute Threshold: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {  # Only run if we have enough data
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Threshold))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q55, device_data$Threshold)
    cat("\nCorrelation between neck size and threshold:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Threshold ~ Q55, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q55, y = Threshold)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Neck Size vs Threshold -", device),
           x = "Neck Circumference (cm)", 
           y = "Threshold") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 2. LOCALIZATION ACCURACY ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== LOCALIZATION ACCURACY ANALYSIS BY DEVICE ===\n")

# Verify structure of localization summary data
cat("Structure of loc_summary:\n")
str(loc_summary)

# Ensure PIDs are character type
loc_summary$PID <- as.character(loc_summary$PID)

# Merge localization data with questionnaire data
# This is where the error occurred previously - we need to know the actual structure
# Print column names to debug
cat("\nColumn names in loc_summary:\n")
print(names(loc_summary))

# Based on column names, choose the appropriate approach:
# Option 1: If data is already in long format with device_type column
if ("device_type" %in% names(loc_summary)) {
  # Data is already in long format
  loc_with_neck <- loc_summary %>%
    inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")
  
  # No need for pivot_longer - data is already in correct format
  loc_long <- loc_with_neck
} else {
  # Option 2: If data is in wide format with separate columns for each device
  # First identify device columns (they should be bracelet, necklace, overear or similar)
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                           "Bracelet", "Necklace", "Overear")
  
  # Find which of these columns actually exist in loc_summary
  device_cols <- intersect(names(loc_summary), possible_device_cols)
  
  if (length(device_cols) > 0) {
    # If we found device columns, use them for pivot_longer
    loc_with_neck <- loc_summary %>%
      inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")
    
    # Convert to long format
    loc_long <- loc_with_neck %>%
      pivot_longer(
        cols = all_of(device_cols),
        names_to = "device_type",
        values_to = "Accuracy"
      ) %>%
      filter(!is.na(Accuracy))
    
    # Ensure device_type is lowercase for consistency
    loc_long$device_type <- tolower(loc_long$device_type)
  } else {
    # Fallback if we don't recognize the data structure
    cat("Warning: Could not identify device columns in loc_summary\n")
    print(names(loc_summary))
    # Create empty dataframe to avoid errors in downstream code
    loc_long <- data.frame(
      PID = character(),
      device_type = character(),
      Accuracy = numeric(),
      Q55 = numeric()
    )
  }
}

# Device-specific models for localization data
for (device in unique(loc_long$device_type)) {
  device_data <- loc_long %>% filter(device_type == device)
  
  cat("\n--- Localization Accuracy: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q55, device_data$Accuracy)
    cat("\nCorrelation between neck size and accuracy:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Accuracy ~ Q55, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q55, y = Accuracy)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Neck Size vs Localization Accuracy -", device),
           x = "Neck Circumference (cm)", 
           y = "Accuracy") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 3. TWO-POINT DISCRIMINATION ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== TWO-POINT DISCRIMINATION ANALYSIS BY DEVICE ===\n")

# Verify structure of two-point summary data
cat("Structure of tp_summary:\n")
str(tp_summary)
cat("\nColumn names in tp_summary:\n")
print(names(tp_summary))

# Apply same logic as with localization data
# Option 1: If data is already in long format
if ("device_type" %in% names(tp_summary)) {
  # Convert PID to character for joining
  tp_with_neck <- tp_summary %>%
    mutate(PID = as.character(PID)) %>%
    inner_join(questionnaire_data %>% select(PID, Q55), by = "PID")
  
  # Data is already in correct format
} else {
  # Option 2: If data is in wide format
  # Find which device columns exist
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                           "Bracelet", "Necklace", "Overear")
  device_cols <- intersect(names(tp_summary), possible_device_cols)
  
  if (length(device_cols) > 0) {
    # Convert to long format
    tp_with_neck <- tp_summary %>%
      mutate(PID = as.character(PID)) %>%
      inner_join(questionnaire_data %>% select(PID, Q55), by = "PID") %>%
      pivot_longer(
        cols = all_of(device_cols),
        names_to = "device_type",
        values_to = "Accuracy"
      ) %>%
      filter(!is.na(Accuracy))
    
    # Ensure device_type is lowercase
    tp_with_neck$device_type <- tolower(tp_with_neck$device_type)
  } else {
    cat("Warning: Could not identify device columns in tp_summary\n")
    print(names(tp_summary))
    # Create empty dataframe
    tp_with_neck <- data.frame(
      PID = character(),
      device_type = character(),
      Accuracy = numeric(),
      Q55 = numeric()
    )
  }
}

# Device-specific models for two-point data
for (device in unique(tp_with_neck$device_type)) {
  device_data <- tp_with_neck %>% filter(device_type == device)
  
  cat("\n--- Two-Point Discrimination: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q55, device_data$Accuracy)
    cat("\nCorrelation between neck size and accuracy:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Accuracy ~ Q55, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q55, y = Accuracy)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Neck Size vs Two-Point Discrimination Accuracy -", device),
           x = "Neck Circumference (cm)", 
           y = "Accuracy") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 4. COMBINED VISUALIZATION OF DEVICE-SPECIFIC EFFECTS
#-----------------------------------------------------------------
cat("\n\n=== COMBINED VISUALIZATION OF DEVICE-SPECIFIC EFFECTS ===\n")

# Initialize a dataframe to store all device-specific effects
device_effects <- data.frame(
  Device = character(),
  Measure = character(),
  Estimate = numeric(),
  SE = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Collect threshold effects
for (device in unique(threshold_with_neck$device_type)) {
  device_data <- threshold_with_neck %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Threshold ~ Q55, data = device_data)
    device_effects <- rbind(device_effects, data.frame(
      Device = device,
      Measure = "Absolute Threshold",
      Estimate = coef(model)["Q55"],
      SE = summary(model)$coefficients["Q55", "Std. Error"],
      p_value = summary(model)$coefficients["Q55", "Pr(>|t|)"]
    ))
  }
}

# Collect localization effects
for (device in unique(loc_long$device_type)) {
  device_data <- loc_long %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Accuracy ~ Q55, data = device_data)
    device_effects <- rbind(device_effects, data.frame(
      Device = device,
      Measure = "Localization Accuracy",
      Estimate = coef(model)["Q55"],
      SE = summary(model)$coefficients["Q55", "Std. Error"],
      p_value = summary(model)$coefficients["Q55", "Pr(>|t|)"]
    ))
  }
}

# Collect two-point effects
for (device in unique(tp_with_neck$device_type)) {
  device_data <- tp_with_neck %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Accuracy ~ Q55, data = device_data)
    device_effects <- rbind(device_effects, data.frame(
      Device = device,
      Measure = "Two-Point Accuracy",
      Estimate = coef(model)["Q55"],
      SE = summary(model)$coefficients["Q55", "Std. Error"],
      p_value = summary(model)$coefficients["Q55", "Pr(>|t|)"]
    ))
  }
}

# Create meaningful labels for the plot
device_effects$Significance <- ifelse(device_effects$p_value < 0.05, "Significant", "Non-significant")
device_effects$Label <- paste(device_effects$Device, "-", device_effects$Measure)
device_effects$Label <- factor(device_effects$Label, levels = device_effects$Label[order(device_effects$Measure, device_effects$Device)])

# Create forest plot of all device-specific effects
if (nrow(device_effects) > 0) {
  p <- ggplot(device_effects, aes(x = Label, y = Estimate, color = Device, shape = Significance)) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = Estimate - 1.96*SE, ymax = Estimate + 1.96*SE), width = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = "Effect of Neck Size on Different Measures by Device",
         x = "",
         y = "Estimate of Neck Size Effect (with 95% CI)") +
    coord_flip() +
    facet_grid(Measure ~ ., scales = "free_y", space = "free") +
    theme_minimal() +
    theme(
      legend.position = "right",
      strip.text = element_text(face = "bold"),
      panel.spacing = unit(1, "lines")
    )
  print(p)
} else {
  cat("Insufficient data for combined visualization\n")
}

#-----------------------------------------------------------------
# 5. WRIST SIZE ANALYSIS - BRACELET DEVICE ONLY
#-----------------------------------------------------------------
cat("\n\n=== WRIST SIZE ANALYSIS - BRACELET DEVICE ONLY ===\n")

# Analyze the relationship between wrist size (Q58) and performance with the bracelet device

# For threshold data
bracelet_threshold <- threshold_results_filtered %>%
  filter(device_type == "bracelet") %>%
  inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")

if (nrow(bracelet_threshold) > 5) {
  cat("\n--- Bracelet Threshold vs Wrist Size ---\n")
  wrist_threshold_model <- lm(Threshold ~ Q58, data = bracelet_threshold)
  print(summary(wrist_threshold_model))
  
  p <- ggplot(bracelet_threshold, aes(x = Q58, y = Threshold)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Wrist Size vs Threshold - Bracelet Device",
         x = "Wrist Circumference (cm)", 
         y = "Threshold") +
    theme_minimal()
  print(p)
} else {
  cat("Insufficient data for bracelet threshold vs wrist size analysis\n")
}

# For localization data - handle both potential data structures
if ("device_type" %in% names(loc_summary)) {
  # If already in long format
  bracelet_loc <- loc_summary %>%
    filter(device_type == "bracelet") %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
} else {
  # If in wide format, check for bracelet column
  if ("bracelet" %in% names(loc_summary) || "Bracelet" %in% names(loc_summary)) {
    bracelet_col <- ifelse("bracelet" %in% names(loc_summary), "bracelet", "Bracelet")
    bracelet_loc <- loc_summary %>%
      select(PID, !!sym(bracelet_col)) %>%
      rename(Accuracy = !!sym(bracelet_col)) %>%
      inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
      filter(!is.na(Accuracy))
  } else {
    # Fallback
    cat("Could not find bracelet data in localization dataset\n")
    bracelet_loc <- data.frame()
  }
}

if (nrow(bracelet_loc) > 5) {
  cat("\n--- Bracelet Localization Accuracy vs Wrist Size ---\n")
  wrist_loc_model <- lm(Accuracy ~ Q58, data = bracelet_loc)
  print(summary(wrist_loc_model))
  
  p <- ggplot(bracelet_loc, aes(x = Q58, y = Accuracy)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Wrist Size vs Localization Accuracy - Bracelet Device",
         x = "Wrist Circumference (cm)", 
         y = "Accuracy") +
    theme_minimal()
  print(p)
} else {
  cat("Insufficient data for bracelet localization vs wrist size analysis\n")
}

# For two-point data - handle both potential data structures
if ("device_type" %in% names(tp_summary)) {
  # If already in long format
  bracelet_tp <- tp_summary %>%
    filter(device_type == "bracelet") %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
} else {
  # If in wide format
  if ("bracelet" %in% names(tp_summary) || "Bracelet" %in% names(tp_summary)) {
    bracelet_col <- ifelse("bracelet" %in% names(tp_summary), "bracelet", "Bracelet")
    bracelet_tp <- tp_summary %>%
      select(PID, !!sym(bracelet_col)) %>%
      rename(Accuracy = !!sym(bracelet_col)) %>%
      inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
      filter(!is.na(Accuracy))
  } else {
    # Fallback
    cat("Could not find bracelet data in two-point dataset\n")
    bracelet_tp <- data.frame()
  }
}

if (nrow(bracelet_tp) > 5) {
  cat("\n--- Bracelet Two-Point Discrimination vs Wrist Size ---\n")
  wrist_tp_model <- lm(Accuracy ~ Q58, data = bracelet_tp)
  print(summary(wrist_tp_model))
  
  p <- ggplot(bracelet_tp, aes(x = Q58, y = Accuracy)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Wrist Size vs Two-Point Discrimination - Bracelet Device",
         x = "Wrist Circumference (cm)", 
         y = "Accuracy") +
    theme_minimal()
  print(p)
} else {
  cat("Insufficient data for bracelet two-point vs wrist size analysis\n")
}

#-----------------------------------------------------------------
# 6. WRIST SIZE FOREST PLOT
#-----------------------------------------------------------------
cat("\n\n=== WRIST SIZE EFFECT VISUALIZATION ===\n")

# Initialize a dataframe to store all device-specific effects for wrist size
wrist_effects <- data.frame(
  Device = character(),
  Measure = character(),
  Estimate = numeric(),
  SE = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Ensure questionnaire_data has PID as character for joining
questionnaire_data$PID <- as.character(questionnaire_data$PID)

# 1. Collect threshold effects for wrist size
for (device in c("bracelet", "necklace", "overear")) {
  # Filter threshold data for this device
  device_data <- threshold_results_filtered %>% 
    filter(device_type == device) %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
  
  # Only proceed if we have enough data
  if (nrow(device_data) > 5) {
    # Fit linear model
    model <- lm(Threshold ~ Q58, data = device_data)
    
    # Extract and store results
    wrist_effects <- rbind(wrist_effects, data.frame(
      Device = device,
      Measure = "Absolute Threshold",
      Estimate = coef(model)["Q58"],
      SE = summary(model)$coefficients["Q58", "Std. Error"],
      p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
    ))
  }
}

# 2. Collect localization effects for wrist size
# Handle both potential data structures for localization data
if ("device_type" %in% names(loc_summary)) {
  # If already in long format
  loc_wrist <- loc_summary %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
  
  # Analyze each device
  for (device in c("bracelet", "necklace", "overear")) {
    device_data <- loc_wrist %>% filter(device_type == device)
    
    if (nrow(device_data) > 5) {
      model <- lm(Accuracy ~ Q58, data = device_data)
      
      wrist_effects <- rbind(wrist_effects, data.frame(
        Device = device,
        Measure = "Localization Accuracy",
        Estimate = coef(model)["Q58"],
        SE = summary(model)$coefficients["Q58", "Std. Error"],
        p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
      ))
    }
  }
} else {
  # If in wide format
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                           "Bracelet", "Necklace", "Overear")
  available_devices <- intersect(names(loc_summary), possible_device_cols)
  
  if (length(available_devices) > 0) {
    for (device_col in available_devices) {
      device_name <- tolower(device_col)
      
      # Create temporary dataset with just this device
      device_data <- loc_summary %>%
        select(PID, !!sym(device_col)) %>%
        rename(Accuracy = !!sym(device_col)) %>%
        inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
        filter(!is.na(Accuracy))
      
      if (nrow(device_data) > 5) {
        model <- lm(Accuracy ~ Q58, data = device_data)
        
        wrist_effects <- rbind(wrist_effects, data.frame(
          Device = device_name,
          Measure = "Localization Accuracy",
          Estimate = coef(model)["Q58"],
          SE = summary(model)$coefficients["Q58", "Std. Error"],
          p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
        ))
      }
    }
  }
}

# 3. Collect two-point effects for wrist size
# Similar approach as for localization
if ("device_type" %in% names(tp_summary)) {
  # If already in long format
  tp_wrist <- tp_summary %>%
    mutate(PID = as.character(PID)) %>%
    inner_join(questionnaire_data %>% select(PID, Q58), by = "PID")
  
  for (device in c("bracelet", "necklace", "overear")) {
    device_data <- tp_wrist %>% filter(device_type == device)
    
    if (nrow(device_data) > 5) {
      model <- lm(Accuracy ~ Q58, data = device_data)
      
      wrist_effects <- rbind(wrist_effects, data.frame(
        Device = device,
        Measure = "Two-Point Accuracy",
        Estimate = coef(model)["Q58"],
        SE = summary(model)$coefficients["Q58", "Std. Error"],
        p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
      ))
    }
  }
} else {
  # If in wide format
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                          "Bracelet", "Necklace", "Overear")
  available_devices <- intersect(names(tp_summary), possible_device_cols)
  
  if (length(available_devices) > 0) {
    for (device_col in available_devices) {
      device_name <- tolower(device_col)
      
      # Create temporary dataset with just this device
      device_data <- tp_summary %>%
        mutate(PID = as.character(PID)) %>%
        select(PID, !!sym(device_col)) %>%
        rename(Accuracy = !!sym(device_col)) %>%
        inner_join(questionnaire_data %>% select(PID, Q58), by = "PID") %>%
        filter(!is.na(Accuracy))
      
      if (nrow(device_data) > 5) {
        model <- lm(Accuracy ~ Q58, data = device_data)
        
        wrist_effects <- rbind(wrist_effects, data.frame(
          Device = device_name,
          Measure = "Two-Point Accuracy",
          Estimate = coef(model)["Q58"],
          SE = summary(model)$coefficients["Q58", "Std. Error"],
          p_value = summary(model)$coefficients["Q58", "Pr(>|t|)"]
        ))
      }
    }
  }
}

# Create meaningful labels for the plot
wrist_effects$Significance <- ifelse(wrist_effects$p_value < 0.05, "Significant", "Non-significant")
wrist_effects$Label <- paste(wrist_effects$Device, "-", wrist_effects$Measure)
wrist_effects$Label <- factor(wrist_effects$Label, 
                             levels = wrist_effects$Label[order(wrist_effects$Measure, wrist_effects$Device)])

# Use device-specific colors
device_colors <- c("bracelet" = "#E69F00", "necklace" = "#56B4E9", "overear" = "#009E73")

# Create forest plot of all device-specific effects for wrist size
if (nrow(wrist_effects) > 0) {
  p <- ggplot(wrist_effects, aes(x = Label, y = Estimate, color = Device, shape = Significance)) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = Estimate - 1.96*SE, ymax = Estimate + 1.96*SE), width = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = "Effect of Wrist Size on Different Measures by Device",
         subtitle = "Coefficients from linear models with 95% confidence intervals",
         x = "",
         y = "Estimate of Wrist Size Effect") +
    scale_color_manual(values = device_colors) +
    scale_shape_manual(values = c("Significant" = 16, "Non-significant" = 1)) +
    coord_flip() +
    facet_grid(Measure ~ ., scales = "free_y", space = "free") +
    theme_minimal() +
    theme(
      legend.position = "right",
      strip.text = element_text(face = "bold"),
      panel.spacing = unit(1, "lines"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank()
    )
  
  print(p)
} else {
  cat("Insufficient data for combined visualization\n")
}

# Display the data table with all effects
print(wrist_effects)


```




## Age

```{r age_effect_analysis, warning = FALSE, message = FALSE}
# Load required libraries
library(tidyverse)
library(ggplot2)
library(lme4)
library(car)

# Display summary statistics for age
cat("Summary of age (Q1):\n")
summary(questionnaire_data$Q1)
cat("\nStandard deviation:", sd(questionnaire_data$Q1, na.rm = TRUE), "\n")
questionnaire_data$Q1 <- as.numeric(as.character(questionnaire_data$Q1))


# Create histogram of age distribution
ggplot(questionnaire_data, aes(x = Q1)) +
  geom_histogram(bins = 10, fill = "green", alpha = 0.7) +
  labs(title = "Distribution of Participant Ages", x = "Age (years)", y = "Count") +
  theme_minimal()

# Ensure PIDs are character type for joining
questionnaire_data$PID <- as.character(questionnaire_data$PID)

#-----------------------------------------------------------------
# DEVICE-SPECIFIC ANALYSIS
#-----------------------------------------------------------------

#-----------------------------------------------------------------
# 1. ABSOLUTE THRESHOLD ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== AGE EFFECT ON ABSOLUTE THRESHOLD BY DEVICE ===\n")

# Merge threshold data with questionnaire data
threshold_with_age <- threshold_results_filtered %>%
  inner_join(questionnaire_data %>% select(PID, Q1), by = "PID")

# Check the merged dataset 
cat("\nRows in merged threshold data:", nrow(threshold_with_age), "\n")

# Device-specific models for threshold data
for (device in unique(threshold_with_age$device_type)) {
  device_data <- threshold_with_age %>% filter(device_type == device)
  
  cat("\n--- Absolute Threshold: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {  # Only run if we have enough data
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Threshold))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q1, device_data$Threshold)
    cat("\nCorrelation between age and threshold:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Threshold ~ Q1, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q1, y = Threshold)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Age vs Threshold -", device),
           x = "Age (years)", 
           y = "Threshold") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 2. LOCALIZATION ACCURACY ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== AGE EFFECT ON LOCALIZATION ACCURACY BY DEVICE ===\n")

# Verify structure of localization summary data
cat("Structure of loc_summary:\n")
str(loc_summary)

# Ensure PIDs are character type
loc_summary$PID <- as.character(loc_summary$PID)

# Merge localization data with questionnaire data
# Check if data is already in long format with device_type column
if ("device_type" %in% names(loc_summary)) {
  # Data is already in long format
  loc_with_age <- loc_summary %>%
    inner_join(questionnaire_data %>% select(PID, Q1), by = "PID")
  
  # No need for pivot_longer - data is already in correct format
  loc_long <- loc_with_age
} else {
  # If data is in wide format with separate columns for each device
  # First identify device columns
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                           "Bracelet", "Necklace", "Overear")
  
  # Find which of these columns actually exist in loc_summary
  device_cols <- intersect(names(loc_summary), possible_device_cols)
  
  if (length(device_cols) > 0) {
    # If we found device columns, use them for pivot_longer
    loc_with_age <- loc_summary %>%
      inner_join(questionnaire_data %>% select(PID, Q1), by = "PID")
    
    # Convert to long format
    loc_long <- loc_with_age %>%
      pivot_longer(
        cols = all_of(device_cols),
        names_to = "device_type",
        values_to = "Accuracy"
      ) %>%
      filter(!is.na(Accuracy))
    
    # Ensure device_type is lowercase for consistency
    loc_long$device_type <- tolower(loc_long$device_type)
  } else {
    # Fallback if we don't recognize the data structure
    cat("Warning: Could not identify device columns in loc_summary\n")
    print(names(loc_summary))
    # Create empty dataframe to avoid errors in downstream code
    loc_long <- data.frame(
      PID = character(),
      device_type = character(),
      Accuracy = numeric(),
      Q1 = numeric()
    )
  }
}

# Device-specific models for localization data
for (device in unique(loc_long$device_type)) {
  device_data <- loc_long %>% filter(device_type == device)
  
  cat("\n--- Localization Accuracy: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q1, device_data$Accuracy)
    cat("\nCorrelation between age and accuracy:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Accuracy ~ Q1, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q1, y = Accuracy)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Age vs Localization Accuracy -", device),
           x = "Age (years)", 
           y = "Accuracy") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 3. TWO-POINT DISCRIMINATION ANALYSIS BY DEVICE
#-----------------------------------------------------------------
cat("\n\n=== AGE EFFECT ON TWO-POINT DISCRIMINATION BY DEVICE ===\n")

# Verify structure of two-point summary data
cat("Structure of tp_summary:\n")
str(tp_summary)
cat("\nColumn names in tp_summary:\n")
print(names(tp_summary))

# Apply same logic as with localization data
# Option 1: If data is already in long format
if ("device_type" %in% names(tp_summary)) {
  # Convert PID to character for joining
  tp_with_age <- tp_summary %>%
    mutate(PID = as.character(PID)) %>%
    inner_join(questionnaire_data %>% select(PID, Q1), by = "PID")
  
  # Data is already in correct format
} else {
  # Option 2: If data is in wide format
  # Find which device columns exist
  possible_device_cols <- c("bracelet", "necklace", "overear", 
                           "Bracelet", "Necklace", "Overear")
  device_cols <- intersect(names(tp_summary), possible_device_cols)
  
  if (length(device_cols) > 0) {
    # Convert to long format
    tp_with_age <- tp_summary %>%
      mutate(PID = as.character(PID)) %>%
      inner_join(questionnaire_data %>% select(PID, Q1), by = "PID") %>%
      pivot_longer(
        cols = all_of(device_cols),
        names_to = "device_type",
        values_to = "Accuracy"
      ) %>%
      filter(!is.na(Accuracy))
    
    # Ensure device_type is lowercase
    tp_with_age$device_type <- tolower(tp_with_age$device_type)
  } else {
    cat("Warning: Could not identify device columns in tp_summary\n")
    print(names(tp_summary))
    # Create empty dataframe
    tp_with_age <- data.frame(
      PID = character(),
      device_type = character(),
      Accuracy = numeric(),
      Q1 = numeric()
    )
  }
}

# Device-specific models for two-point data
for (device in unique(tp_with_age$device_type)) {
  device_data <- tp_with_age %>% filter(device_type == device)
  
  cat("\n--- Two-Point Discrimination: Device =", device, "---\n")
  cat("Number of observations:", nrow(device_data), "\n")
  
  if (nrow(device_data) > 5) {
    # Summary statistics
    cat("Summary statistics for this device:\n")
    print(summary(device_data$Accuracy))
    
    # Correlation test
    cor_test <- cor.test(device_data$Q1, device_data$Accuracy)
    cat("\nCorrelation between age and accuracy:\n")
    cat("r =", round(cor_test$estimate, 3), ", p =", round(cor_test$p.value, 3), "\n")
    
    # Linear model
    device_model <- lm(Accuracy ~ Q1, data = device_data)
    cat("\nLinear model for this device:\n")
    print(summary(device_model))
    
    # Plot
    p <- ggplot(device_data, aes(x = Q1, y = Accuracy)) +
      geom_point() +
      geom_smooth(method = "lm") +
      labs(title = paste("Age vs Two-Point Discrimination Accuracy -", device),
           x = "Age (years)", 
           y = "Accuracy") +
      theme_minimal()
    print(p)
  } else {
    cat("Insufficient data for analysis\n")
  }
}

#-----------------------------------------------------------------
# 4. COMBINED VISUALIZATION OF AGE EFFECTS
#-----------------------------------------------------------------
cat("\n\n=== COMBINED VISUALIZATION OF AGE EFFECTS ===\n")

# Initialize a dataframe to store all device-specific effects
age_effects <- data.frame(
  Device = character(),
  Measure = character(),
  Estimate = numeric(),
  SE = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Collect threshold effects
for (device in unique(threshold_with_age$device_type)) {
  device_data <- threshold_with_age %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Threshold ~ Q1, data = device_data)
    age_effects <- rbind(age_effects, data.frame(
      Device = device,
      Measure = "Absolute Threshold",
      Estimate = coef(model)["Q1"],
      SE = summary(model)$coefficients["Q1", "Std. Error"],
      p_value = summary(model)$coefficients["Q1", "Pr(>|t|)"]
    ))
  }
}

# Collect localization effects
for (device in unique(loc_long$device_type)) {
  device_data <- loc_long %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Accuracy ~ Q1, data = device_data)
    age_effects <- rbind(age_effects, data.frame(
      Device = device,
      Measure = "Localization Accuracy",
      Estimate = coef(model)["Q1"],
      SE = summary(model)$coefficients["Q1", "Std. Error"],
      p_value = summary(model)$coefficients["Q1", "Pr(>|t|)"]
    ))
  }
}

# Collect two-point effects
for (device in unique(tp_with_age$device_type)) {
  device_data <- tp_with_age %>% filter(device_type == device)
  if (nrow(device_data) > 5) {
    model <- lm(Accuracy ~ Q1, data = device_data)
    age_effects <- rbind(age_effects, data.frame(
      Device = device,
      Measure = "Two-Point Accuracy",
      Estimate = coef(model)["Q1"],
      SE = summary(model)$coefficients["Q1", "Std. Error"],
      p_value = summary(model)$coefficients["Q1", "Pr(>|t|)"]
    ))
  }
}

# Create meaningful labels for the plot
age_effects$Significance <- ifelse(age_effects$p_value < 0.05, "Significant", "Non-significant")
age_effects$Label <- paste(age_effects$Device, "-", age_effects$Measure)
age_effects$Label <- factor(age_effects$Label, levels = age_effects$Label[order(age_effects$Measure, age_effects$Device)])

# Create forest plot of all device-specific effects
if (nrow(age_effects) > 0) {
  # Use device-specific colors
  device_colors <- c("bracelet" = "#E69F00", "necklace" = "#56B4E9", "overear" = "#009E73")
  
  p <- ggplot(age_effects, aes(x = Label, y = Estimate, color = Device, shape = Significance)) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = Estimate - 1.96*SE, ymax = Estimate + 1.96*SE), width = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = "Effect of Age on Different Measures by Device",
         x = "",
         y = "Estimate of Age Effect (with 95% CI)") +
    scale_color_manual(values = device_colors) +
    scale_shape_manual(values = c("Significant" = 16, "Non-significant" = 1)) +
    coord_flip() +
    facet_grid(Measure ~ ., scales = "free_y", space = "free") +
    theme_minimal() +
    theme(
      legend.position = "right",
      strip.text = element_text(face = "bold"),
      panel.spacing = unit(1, "lines"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank()
    )
  print(p)
} else {
  cat("Insufficient data for combined visualization\n")
}

# Display the data table with all effects
print(age_effects)

#-----------------------------------------------------------------
# 5. INVESTIGATING AGE AS A CONFOUNDING VARIABLE
#-----------------------------------------------------------------
cat("\n\n=== INVESTIGATING AGE AS A CONFOUNDING VARIABLE ===\n")

# Check correlations between age and anatomical measurements
age_neck_cor <- cor.test(questionnaire_data$Q1, questionnaire_data$Q55, use = "pairwise.complete.obs")
age_wrist_cor <- cor.test(questionnaire_data$Q1, questionnaire_data$Q58, use = "pairwise.complete.obs")

cat("\nCorrelation between age and neck size:\n")
cat("r =", round(age_neck_cor$estimate, 3), ", p =", round(age_neck_cor$p.value, 3), "\n")

cat("\nCorrelation between age and wrist size:\n")
cat("r =", round(age_wrist_cor$estimate, 3), ", p =", round(age_wrist_cor$p.value, 3), "\n")

# Scatter plots to visualize these relationships
p1 <- ggplot(questionnaire_data, aes(x = Q1, y = Q55)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Relationship Between Age and Neck Size",
       x = "Age (years)",
       y = "Neck Circumference (cm)") +
  theme_minimal()

p2 <- ggplot(questionnaire_data, aes(x = Q1, y = Q58)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Relationship Between Age and Wrist Size",
       x = "Age (years)",
       y = "Wrist Circumference (cm)") +
  theme_minimal()

print(p1)
print(p2)

# Run multiple regression models for each device to see if age and anatomical
# measurements have independent effects (using absolute threshold as example)

cat("\n=== Multiple regression: Age + Anatomical Measurements ===\n")

# For each device type, run models with both age and neck/wrist measurements
for (device in unique(threshold_results_filtered$device_type)) {
  # First with neck size
  device_data_neck <- threshold_results_filtered %>% 
    filter(device_type == device) %>%
    inner_join(questionnaire_data %>% select(PID, Q1, Q55), by = "PID")
  
  # Then with wrist size if it's a bracelet
  if (device == "bracelet") {
    device_data_wrist <- threshold_results_filtered %>% 
      filter(device_type == device) %>%
      inner_join(questionnaire_data %>% select(PID, Q1, Q58), by = "PID")
  }
  
  cat("\n--- Multiple regression for", device, "device ---\n")
  
  # Neck size + age
  if (nrow(device_data_neck) > 5) {
    cat("\nModel with age and neck size:\n")
    model_neck <- lm(Threshold ~ Q1 + Q55, data = device_data_neck)
    print(summary(model_neck))
    
    # Calculate semi-partial correlations to assess unique contributions
    cat("\nANOVA to assess unique contributions:\n")
    print(Anova(model_neck, type = 2))
  }
  
  # Wrist size + age (only for bracelet)
  if (device == "bracelet" && nrow(device_data_wrist) > 5) {
    cat("\nModel with age and wrist size:\n")
    model_wrist <- lm(Threshold ~ Q1 + Q58, data = device_data_wrist)
    print(summary(model_wrist))
    
    # Calculate semi-partial correlations
    cat("\nANOVA to assess unique contributions:\n")
    print(Anova(model_wrist, type = 2))
  }
}
```
